<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# Configuração da porta serial do Arduino&#10;ARDUINO_PORT=COM3&#10;&#10;# Para Linux/Mac use algo como:&#10;# ARDUINO_PORT=/dev/ttyUSB0&#10;# ARDUINO_PORT=/dev/ttyACM0&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app.js" />
              <option name="originalContent" value="console.log(&quot;Peixe&quot;);&#10;var createError = require('http-errors');&#10;var express = require('express');&#10;var climaRouter = require('./routes/clima');&#10;var path = require('path');&#10;const axios = require('axios');&#10;&#10;var cookieParser = require('cookie-parser');&#10;var logger = require('morgan');&#10;var app = express();&#10;var indexRouter = require('./routes/index');&#10;var usersRouter = require('./routes/users');&#10;const trataDados = require('./scripts/trataDadosClimaticos');&#10;const arduino = require('./arduino/arduino');&#10;&#10;// Inicializa o sistema de monitoramento&#10;trataDados.inicializar();&#10;&#10;&#10;app.use('/clima', climaRouter);&#10;&#10;// Rota para status do Arduino&#10;app.get('/arduino-status', (req, res) =&gt; {&#10;    const dados = arduino.obterDados();&#10;    res.json({&#10;        conectado: dados !== null,&#10;        ultima_leitura: dados&#10;    });&#10;});&#10;&#10;app.get(&quot;/teste&quot;, (req, res) =&gt; {&#10;    res.render('index');&#10;})&#10;&#10;// Rota para obter previsão de qualidade do ar&#10;app.get('/previsao-ar', (req, res) =&gt; {&#10;    res.json(trataDados.obterRecomendacoes());&#10;});&#10;&#10;// Rota para definir localização (POST ou GET com query param)&#10;app.post('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.body.local;&#10;        if (!local) {&#10;            return res.status(400).json({ erro: 'Parâmetro &quot;local&quot; é obrigatório' });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota alternativa GET para definir localização&#10;app.get('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.query.local;&#10;        if (!local) {&#10;            return res.status(400).json({&#10;                erro: 'Parâmetro &quot;local&quot; é obrigatório',&#10;                exemplo: '/localizar?local=Sorocaba, SP'&#10;            });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota para obter localização atual&#10;app.get('/localizacao-atual', (req, res) =&gt; {&#10;    res.json(trataDados.obterLocalizacaoAtual());&#10;});&#10;&#10;app.set('views', path.join(__dirname, 'views'));&#10;&#10;app.set('view engine', 'pug');&#10;app.use(logger('dev'));&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;app.use(cookieParser());&#10;&#10;&#10;app.use(express.static(path.join(__dirname, 'public')));&#10;app.use('/users', usersRouter);&#10;app.use('/', indexRouter);&#10;&#10;// catch 404 and forward to error handler&#10;app.use(function(req, res, next) {&#10;  next(createError(404));&#10;});&#10;&#10;// error handler&#10;app.use(function(err, req, res, next) {&#10;  // set locals, only providing error in development&#10;  res.locals.message = err.message;&#10;  res.locals.error = req.app.get('env') === 'development' ? err : {};&#10;&#10;  // render the error page&#10;  res.status(err.status || 500);&#10;  res.render('error');&#10;});&#10;&#10;module.exports = app;" />
              <option name="updatedContent" value="console.log(&quot;Peixe&quot;);&#10;var createError = require('http-errors');&#10;var express = require('express');&#10;var climaRouter = require('./routes/clima');&#10;var path = require('path');&#10;const axios = require('axios');&#10;&#10;var cookieParser = require('cookie-parser');&#10;var logger = require('morgan');&#10;var app = express();&#10;var indexRouter = require('./routes/index');&#10;var usersRouter = require('./routes/users');&#10;const trataDados = require('./scripts/trataDadosClimaticos');&#10;const arduino = require('./arduino/arduino');&#10;&#10;// Inicializa o sistema de monitoramento&#10;trataDados.inicializar();&#10;&#10;&#10;app.use('/clima', climaRouter);&#10;&#10;// Rota para status do Arduino&#10;app.get('/arduino-status', (req, res) =&gt; {&#10;    const dados = arduino.obterDados();&#10;    res.json({&#10;        conectado: dados !== null,&#10;        ultima_leitura: dados&#10;    });&#10;});&#10;&#10;app.get(&quot;/teste&quot;, (req, res) =&gt; {&#10;    res.render('index');&#10;})&#10;&#10;// Rota para obter previsão de qualidade do ar&#10;app.get('/previsao-ar', (req, res) =&gt; {&#10;    res.json(trataDados.obterRecomendacoes());&#10;});&#10;&#10;// Rota para definir localização (POST ou GET com query param)&#10;app.post('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.body.local;&#10;        if (!local) {&#10;            return res.status(400).json({ erro: 'Parâmetro &quot;local&quot; é obrigatório' });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota alternativa GET para definir localização&#10;app.get('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.query.local;&#10;        if (!local) {&#10;            return res.status(400).json({&#10;                erro: 'Parâmetro &quot;local&quot; é obrigatório',&#10;                exemplo: '/localizar?local=Sorocaba, SP'&#10;            });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota para obter localização atual&#10;app.get('/localizacao-atual', (req, res) =&gt; {&#10;    res.json(trataDados.obterLocalizacaoAtual());&#10;});&#10;&#10;app.set('views', path.join(__dirname, 'views'));&#10;&#10;app.set('view engine', 'pug');&#10;app.use(logger('dev'));&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;app.use(cookieParser());&#10;&#10;&#10;app.use(express.static(path.join(__dirname, 'public')));&#10;app.use('/users', usersRouter);&#10;app.use('/', indexRouter);&#10;&#10;// catch 404 and forward to error handler&#10;app.use(function(req, res, next) {&#10;  next(createError(404));&#10;});&#10;&#10;// error handler&#10;app.use(function(err, req, res, next) {&#10;  // set locals, only providing error in development&#10;  res.locals.message = err.message;&#10;  res.locals.error = req.app.get('env') === 'development' ? err : {};&#10;&#10;  // render the error page&#10;  res.status(err.status || 500);&#10;  res.render('error');&#10;});&#10;&#10;module.exports = app;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/arduino/arduino_sketch.ino">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/arduino/arduino_sketch.ino" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="// Sketch Arduino para enviar dados de sensores e receber recomendações&#10;// Sensores conectados nas portas A0-A4&#10;// LEDs/Relés conectados nas portas digitais 8-12&#10;&#10;// Pinos dos LEDs/Relés para as recomendações&#10;#define LED_FECHAR_JANELAS 8&#10;#define LED_ATIVAR_PURIFICADOR 9&#10;#define LED_USAR_MASCARAS 10&#10;#define LED_SE_HIDRATAR 11&#10;#define LED_TEMPO_CATEGORIA 12  // LED indicador de urgência&#10;&#10;String inputString = &quot;&quot;;&#10;boolean stringComplete = false;&#10;&#10;void setup() {&#10;    Serial.begin(9600);&#10;    &#10;    // Configura pinos dos sensores&#10;    pinMode(A0, INPUT); // Sensor PM2.5&#10;    pinMode(A1, INPUT); // Sensor NO2&#10;    pinMode(A2, INPUT); // Sensor O3&#10;    pinMode(A3, INPUT); // Sensor CO&#10;    pinMode(A4, INPUT); // Sensor Umidade&#10;    &#10;    // Configura pinos dos LEDs/Relés como saída&#10;    pinMode(LED_FECHAR_JANELAS, OUTPUT);&#10;    pinMode(LED_ATIVAR_PURIFICADOR, OUTPUT);&#10;    pinMode(LED_USAR_MASCARAS, OUTPUT);&#10;    pinMode(LED_SE_HIDRATAR, OUTPUT);&#10;    pinMode(LED_TEMPO_CATEGORIA, OUTPUT);&#10;    &#10;    // Inicia com todos os LEDs desligados&#10;    digitalWrite(LED_FECHAR_JANELAS, LOW);&#10;    digitalWrite(LED_ATIVAR_PURIFICADOR, LOW);&#10;    digitalWrite(LED_USAR_MASCARAS, LOW);&#10;    digitalWrite(LED_SE_HIDRATAR, LOW);&#10;    digitalWrite(LED_TEMPO_CATEGORIA, LOW);&#10;    &#10;    inputString.reserve(200);&#10;}&#10;&#10;void loop() {&#10;    // Lê valores dos sensores (adapte conforme seus sensores reais)&#10;    float pm25 = analogRead(A0) * 0.1;     // PM2.5 em µg/m³&#10;    float no2 = analogRead(A1) * 0.5;      // NO2 em µg/m³&#10;    float o3 = analogRead(A2) * 0.3;       // O3 em µg/m³&#10;    float co = analogRead(A3) * 0.2;       // CO em mg/m³&#10;    float umidade = analogRead(A4) * 0.09; // Umidade em %&#10;&#10;    // Envia JSON com dados dos sensores&#10;    Serial.print(&quot;{\&quot;pm25\&quot;:&quot;);&#10;    Serial.print(pm25, 2);&#10;    Serial.print(&quot;,\&quot;no2\&quot;:&quot;);&#10;    Serial.print(no2, 2);&#10;    Serial.print(&quot;,\&quot;o3\&quot;:&quot;);&#10;    Serial.print(o3, 2);&#10;    Serial.print(&quot;,\&quot;co\&quot;:&quot;);&#10;    Serial.print(co, 2);&#10;    Serial.print(&quot;,\&quot;umidade\&quot;:&quot;);&#10;    Serial.print(umidade, 2);&#10;    Serial.println(&quot;}&quot;);&#10;&#10;    // Processa recomendações recebidas via serial&#10;    if (stringComplete) {&#10;        processarRecomendacoes(inputString);&#10;        inputString = &quot;&quot;;&#10;        stringComplete = false;&#10;    }&#10;&#10;    delay(2000); // Aguarda 2 segundos&#10;}&#10;&#10;// Função chamada automaticamente quando chega dados na serial&#10;void serialEvent() {&#10;    while (Serial.available()) {&#10;        char inChar = (char)Serial.read();&#10;        inputString += inChar;&#10;        if (inChar == '\n') {&#10;            stringComplete = true;&#10;        }&#10;    }&#10;}&#10;&#10;// Processa JSON de recomendações recebido&#10;void processarRecomendacoes(String json) {&#10;    // Parse simples do JSON (ou use biblioteca ArduinoJson para JSON complexo)&#10;    boolean fechar_janelas = json.indexOf(&quot;\&quot;fechar_janelas\&quot;:true&quot;) &gt; 0;&#10;    boolean ativar_purificador = json.indexOf(&quot;\&quot;ativar_purificador\&quot;:true&quot;) &gt; 0;&#10;    boolean usar_mascaras = json.indexOf(&quot;\&quot;usar_mascaras\&quot;:true&quot;) &gt; 0;&#10;    boolean se_hidratar = json.indexOf(&quot;\&quot;sehidratar_controlar_humidade\&quot;:true&quot;) &gt; 0;&#10;    &#10;    // Extrai tempo_categoria (0, 1, 2 ou 3)&#10;    int tempo_categoria = 0;&#10;    int idx = json.indexOf(&quot;\&quot;tempo_categoria\&quot;:&quot;);&#10;    if (idx &gt; 0) {&#10;        tempo_categoria = json.substring(idx + 18, idx + 19).toInt();&#10;    }&#10;    &#10;    // Aciona LEDs/Relés conforme as recomendações&#10;    digitalWrite(LED_FECHAR_JANELAS, fechar_janelas ? HIGH : LOW);&#10;    digitalWrite(LED_ATIVAR_PURIFICADOR, ativar_purificador ? HIGH : LOW);&#10;    digitalWrite(LED_USAR_MASCARAS, usar_mascaras ? HIGH : LOW);&#10;    digitalWrite(LED_SE_HIDRATAR, se_hidratar ? HIGH : LOW);&#10;    &#10;    // LED de urgência pisca conforme tempo_categoria&#10;    // 0=Desligado, 1=Lento, 2=Médio, 3=Rápido&#10;    if (tempo_categoria == 0) {&#10;        digitalWrite(LED_TEMPO_CATEGORIA, LOW);&#10;    } else if (tempo_categoria &gt;= 2) {&#10;        digitalWrite(LED_TEMPO_CATEGORIA, HIGH); // Urgente = sempre ligado&#10;    } else {&#10;        // Pisca lento para categoria 1&#10;        digitalWrite(LED_TEMPO_CATEGORIA, millis() % 1000 &lt; 500 ? HIGH : LOW);&#10;    }&#10;    &#10;    // Debug: imprime status&#10;    Serial.print(&quot;&gt;&gt; Janelas:&quot;);&#10;    Serial.print(fechar_janelas);&#10;    Serial.print(&quot; Purif:&quot;);&#10;    Serial.print(ativar_purificador);&#10;    Serial.print(&quot; Mask:&quot;);&#10;    Serial.print(usar_mascaras);&#10;    Serial.print(&quot; Hidr:&quot;);&#10;    Serial.print(se_hidratar);&#10;    Serial.print(&quot; Tempo:&quot;);&#10;    Serial.println(tempo_categoria);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>