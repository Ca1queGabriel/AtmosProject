<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# Configuração da porta serial do Arduino&#10;ARDUINO_PORT=COM3&#10;&#10;# Para Linux/Mac use algo como:&#10;# ARDUINO_PORT=/dev/ttyUSB0&#10;# ARDUINO_PORT=/dev/ttyACM0&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app.js" />
              <option name="originalContent" value="console.log(&quot;Peixe&quot;);&#10;var createError = require('http-errors');&#10;var express = require('express');&#10;var climaRouter = require('./routes/clima');&#10;var path = require('path');&#10;const axios = require('axios');&#10;&#10;var cookieParser = require('cookie-parser');&#10;var logger = require('morgan');&#10;var app = express();&#10;var indexRouter = require('./routes/index');&#10;var usersRouter = require('./routes/users');&#10;const trataDados = require('./scripts/trataDadosClimaticos');&#10;const arduino = require('./arduino/arduino');&#10;&#10;// Inicializa o sistema de monitoramento&#10;trataDados.inicializar();&#10;&#10;&#10;app.use('/clima', climaRouter);&#10;&#10;// Rota para status do Arduino&#10;app.get('/arduino-status', (req, res) =&gt; {&#10;    const dados = arduino.obterDados();&#10;    res.json({&#10;        conectado: dados !== null,&#10;        ultima_leitura: dados&#10;    });&#10;});&#10;&#10;app.get(&quot;/teste&quot;, (req, res) =&gt; {&#10;    res.render('index');&#10;})&#10;&#10;// Rota para obter previsão de qualidade do ar&#10;app.get('/previsao-ar', (req, res) =&gt; {&#10;    res.json(trataDados.obterRecomendacoes());&#10;});&#10;&#10;// Rota para definir localização (POST ou GET com query param)&#10;app.post('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.body.local;&#10;        if (!local) {&#10;            return res.status(400).json({ erro: 'Parâmetro &quot;local&quot; é obrigatório' });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota alternativa GET para definir localização&#10;app.get('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.query.local;&#10;        if (!local) {&#10;            return res.status(400).json({&#10;                erro: 'Parâmetro &quot;local&quot; é obrigatório',&#10;                exemplo: '/localizar?local=Sorocaba, SP'&#10;            });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota para obter localização atual&#10;app.get('/localizacao-atual', (req, res) =&gt; {&#10;    res.json(trataDados.obterLocalizacaoAtual());&#10;});&#10;&#10;app.set('views', path.join(__dirname, 'views'));&#10;&#10;app.set('view engine', 'pug');&#10;app.use(logger('dev'));&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;app.use(cookieParser());&#10;&#10;&#10;app.use(express.static(path.join(__dirname, 'public')));&#10;app.use('/users', usersRouter);&#10;app.use('/', indexRouter);&#10;&#10;// catch 404 and forward to error handler&#10;app.use(function(req, res, next) {&#10;  next(createError(404));&#10;});&#10;&#10;// error handler&#10;app.use(function(err, req, res, next) {&#10;  // set locals, only providing error in development&#10;  res.locals.message = err.message;&#10;  res.locals.error = req.app.get('env') === 'development' ? err : {};&#10;&#10;  // render the error page&#10;  res.status(err.status || 500);&#10;  res.render('error');&#10;});&#10;&#10;module.exports = app;" />
              <option name="updatedContent" value="console.log(&quot;Peixe&quot;);&#10;var createError = require('http-errors');&#10;var express = require('express');&#10;var climaRouter = require('./routes/clima');&#10;var path = require('path');&#10;const axios = require('axios');&#10;&#10;var cookieParser = require('cookie-parser');&#10;var logger = require('morgan');&#10;var app = express();&#10;var indexRouter = require('./routes/index');&#10;var usersRouter = require('./routes/users');&#10;const trataDados = require('./scripts/trataDadosClimaticos');&#10;const arduino = require('./arduino/arduino');&#10;&#10;// Inicializa o sistema de monitoramento&#10;trataDados.inicializar();&#10;&#10;&#10;app.use('/clima', climaRouter);&#10;&#10;// Rota para status do Arduino&#10;app.get('/arduino-status', (req, res) =&gt; {&#10;    const dados = arduino.obterDados();&#10;    res.json({&#10;        conectado: dados !== null,&#10;        ultima_leitura: dados&#10;    });&#10;});&#10;&#10;app.get(&quot;/teste&quot;, (req, res) =&gt; {&#10;    res.render('index');&#10;})&#10;&#10;// Rota para obter previsão de qualidade do ar&#10;app.get('/previsao-ar', (req, res) =&gt; {&#10;    res.json(trataDados.obterRecomendacoes());&#10;});&#10;&#10;// Rota para definir localização (POST ou GET com query param)&#10;app.post('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.body.local;&#10;        if (!local) {&#10;            return res.status(400).json({ erro: 'Parâmetro &quot;local&quot; é obrigatório' });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota alternativa GET para definir localização&#10;app.get('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.query.local;&#10;        if (!local) {&#10;            return res.status(400).json({&#10;                erro: 'Parâmetro &quot;local&quot; é obrigatório',&#10;                exemplo: '/localizar?local=Sorocaba, SP'&#10;            });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota para obter localização atual&#10;app.get('/localizacao-atual', (req, res) =&gt; {&#10;    res.json(trataDados.obterLocalizacaoAtual());&#10;});&#10;&#10;app.set('views', path.join(__dirname, 'views'));&#10;&#10;app.set('view engine', 'pug');&#10;app.use(logger('dev'));&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;app.use(cookieParser());&#10;&#10;&#10;app.use(express.static(path.join(__dirname, 'public')));&#10;app.use('/users', usersRouter);&#10;app.use('/', indexRouter);&#10;&#10;// catch 404 and forward to error handler&#10;app.use(function(req, res, next) {&#10;  next(createError(404));&#10;});&#10;&#10;// error handler&#10;app.use(function(err, req, res, next) {&#10;  // set locals, only providing error in development&#10;  res.locals.message = err.message;&#10;  res.locals.error = req.app.get('env') === 'development' ? err : {};&#10;&#10;  // render the error page&#10;  res.status(err.status || 500);&#10;  res.render('error');&#10;});&#10;&#10;module.exports = app;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/arduino/arduino.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/arduino/arduino.js" />
              <option name="originalContent" value="//parte dedicada à conexão com o arduino&#10;&#10;const { SerialPort } = require('serialport');&#10;const { ReadlineParser } = require('@serialport/parser-readline');&#10;&#10;let porta = null;&#10;let parser = null;&#10;let ultimaLeitura = null;&#10;&#10;function conectar() {&#10;    try {&#10;        porta = new SerialPort({&#10;            path: process.env.ARDUINO_PORT || 'COM3',&#10;            baudRate: 9600&#10;        });&#10;&#10;        parser = porta.pipe(new ReadlineParser({ delimiter: '\n' }));&#10;&#10;        porta.on('open', () =&gt; {&#10;            console.log(`✅ Arduino conectado na porta ${process.env.ARDUINO_PORT || 'COM3'}`);&#10;        });&#10;&#10;        parser.on('data', (linha) =&gt; {&#10;            try {&#10;                const dados = JSON.parse(linha);&#10;                ultimaLeitura = {&#10;                    ...dados,&#10;                    timestamp: new Date().toISOString()&#10;                };&#10;                console.log(' Dados recebidos:', ultimaLeitura);&#10;            } catch (erro) {&#10;                console.error('Erro ao parsear dados:', linha);&#10;            }&#10;        });&#10;&#10;        porta.on('error', (erro) =&gt; {&#10;            console.error('❌ Erro na porta serial:', erro.message);&#10;        });&#10;&#10;    } catch (erro) {&#10;        console.error('❌ Falha ao conectar Arduino:', erro.message);&#10;    }&#10;}&#10;&#10;function obterDados() {&#10;    return ultimaLeitura;&#10;}&#10;&#10;function enviarRecomendacoes(recomendacoes) {&#10;    if (!porta || !porta.isOpen) {&#10;        console.warn('⚠️  Arduino não conectado. Não é possível enviar dados.');&#10;        return false;&#10;    }&#10;&#10;    try {&#10;        // Extrai apenas os 5 dados necessários&#10;        const dados = {&#10;            fechar_janelas: recomendacoes.fechar_janelas || false,&#10;            ativar_purificador: recomendacoes.ativar_purificador || false,&#10;            usar_mascaras: recomendacoes.usar_mascaras || false,&#10;            sehidratar_controlar_humidade: recomendacoes['se_hidratar/Controlar_humidade'] || false,&#10;            tempo_categoria: recomendacoes.tempo_categoria || 0&#10;        };&#10;&#10;        // Converte para JSON e envia via serial&#10;        const json = JSON.stringify(dados);&#10;        porta.write(json + '\n', (err) =&gt; {&#10;            if (err) {&#10;                console.error('❌ Erro ao enviar dados:', err.message);&#10;            } else {&#10;                console.log(' Recomendações enviadas:', dados);&#10;            }&#10;        });&#10;&#10;        return true;&#10;    } catch (erro) {&#10;        console.error('❌ Erro ao processar envio:', erro.message);&#10;        return false;&#10;    }&#10;}&#10;&#10;function desconectar() {&#10;    if (porta &amp;&amp; porta.isOpen) {&#10;        porta.close();&#10;        console.log('Arduino desconectado');&#10;    }&#10;}&#10;&#10;module.exports = {&#10;    conectar,&#10;    obterDados,&#10;    enviarRecomendacoes,&#10;    desconectar&#10;};&#10;" />
              <option name="updatedContent" value="//parte dedicada à conexão com o arduino&#10;&#10;const { SerialPort } = require('serialport');&#10;const { ReadlineParser } = require('@serialport/parser-readline');&#10;&#10;let porta = null;&#10;let parser = null;&#10;let ultimaLeitura = null;&#10;&#10;function conectar() {&#10;    try {&#10;        porta = new SerialPort({&#10;            path: process.env.ARDUINO_PORT || 'COM3',&#10;            baudRate: 9600&#10;        });&#10;&#10;        parser = porta.pipe(new ReadlineParser({ delimiter: '\n' }));&#10;&#10;        porta.on('open', () =&gt; {&#10;            console.log(`✅ Arduino conectado na porta ${process.env.ARDUINO_PORT || 'COM3'}`);&#10;        });&#10;&#10;        parser.on('data', (linha) =&gt; {&#10;            try {&#10;                const dados = JSON.parse(linha);&#10;                ultimaLeitura = {&#10;                    ...dados,&#10;                    timestamp: new Date().toISOString()&#10;                };&#10;                console.log(' Dados recebidos:', ultimaLeitura);&#10;            } catch (erro) {&#10;                console.error('Erro ao parsear dados:', linha);&#10;            }&#10;        });&#10;&#10;        porta.on('error', (erro) =&gt; {&#10;            console.error('❌ Erro na porta serial:', erro.message);&#10;        });&#10;&#10;    } catch (erro) {&#10;        console.error('❌ Falha ao conectar Arduino:', erro.message);&#10;    }&#10;}&#10;&#10;function obterDados() {&#10;    return ultimaLeitura;&#10;}&#10;&#10;function enviarRecomendacoes(recomendacoes) {&#10;    if (!porta || !porta.isOpen) {&#10;        console.warn('⚠️  Arduino não conectado. Não é possível enviar dados.');&#10;        return false;&#10;    }&#10;&#10;    try {&#10;        // Extrai apenas os 5 dados necessários&#10;        const dados = {&#10;            fechar_janelas: recomendacoes.fechar_janelas || false,&#10;            ativar_purificador: recomendacoes.ativar_purificador || false,&#10;            usar_mascaras: recomendacoes.usar_mascaras || false,&#10;            sehidratar_controlar_humidade: recomendacoes['se_hidratar/Controlar_humidade'] || false,&#10;            tempo_categoria: recomendacoes.tempo_categoria || 0&#10;        };&#10;&#10;        // Converte para JSON e envia via serial&#10;        const json = JSON.stringify(dados);&#10;        porta.write(json + '\n', (err) =&gt; {&#10;            if (err) {&#10;                console.error('❌ Erro ao enviar dados:', err.message);&#10;            } else {&#10;                console.log(' Recomendações enviadas:', dados);&#10;            }&#10;        });&#10;&#10;        return true;&#10;    } catch (erro) {&#10;        console.error('❌ Erro ao processar envio:', erro.message);&#10;        return false;&#10;    }&#10;}&#10;&#10;function desconectar() {&#10;    if (porta &amp;&amp; porta.isOpen) {&#10;        porta.close();&#10;        console.log('Arduino desconectado');&#10;    }&#10;}&#10;&#10;module.exports = {&#10;    conectar,&#10;    obterDados,&#10;    enviarRecomendacoes,&#10;    desconectar&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/arduino/arduino_sketch.ino">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/arduino/arduino_sketch.ino" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="// Sketch Arduino para enviar dados de sensores e receber recomendações&#10;// Sensores conectados nas portas A0-A4&#10;// LEDs/Relés conectados nas portas digitais 8-12&#10;&#10;// Pinos dos LEDs/Relés para as recomendações&#10;#define LED_FECHAR_JANELAS 8&#10;#define LED_ATIVAR_PURIFICADOR 9&#10;#define LED_USAR_MASCARAS 10&#10;#define LED_SE_HIDRATAR 11&#10;#define LED_TEMPO_CATEGORIA 12  // LED indicador de urgência&#10;&#10;String inputString = &quot;&quot;;&#10;boolean stringComplete = false;&#10;&#10;void setup() {&#10;    Serial.begin(9600);&#10;    &#10;    // Configura pinos dos sensores&#10;    pinMode(A0, INPUT); // Sensor PM2.5&#10;    pinMode(A1, INPUT); // Sensor NO2&#10;    pinMode(A2, INPUT); // Sensor O3&#10;    pinMode(A3, INPUT); // Sensor CO&#10;    pinMode(A4, INPUT); // Sensor Umidade&#10;    &#10;    // Configura pinos dos LEDs/Relés como saída&#10;    pinMode(LED_FECHAR_JANELAS, OUTPUT);&#10;    pinMode(LED_ATIVAR_PURIFICADOR, OUTPUT);&#10;    pinMode(LED_USAR_MASCARAS, OUTPUT);&#10;    pinMode(LED_SE_HIDRATAR, OUTPUT);&#10;    pinMode(LED_TEMPO_CATEGORIA, OUTPUT);&#10;    &#10;    // Inicia com todos os LEDs desligados&#10;    digitalWrite(LED_FECHAR_JANELAS, LOW);&#10;    digitalWrite(LED_ATIVAR_PURIFICADOR, LOW);&#10;    digitalWrite(LED_USAR_MASCARAS, LOW);&#10;    digitalWrite(LED_SE_HIDRATAR, LOW);&#10;    digitalWrite(LED_TEMPO_CATEGORIA, LOW);&#10;    &#10;    inputString.reserve(200);&#10;}&#10;&#10;void loop() {&#10;    // Lê valores dos sensores (adapte conforme seus sensores reais)&#10;    float pm25 = analogRead(A0) * 0.1;     // PM2.5 em µg/m³&#10;    float no2 = analogRead(A1) * 0.5;      // NO2 em µg/m³&#10;    float o3 = analogRead(A2) * 0.3;       // O3 em µg/m³&#10;    float co = analogRead(A3) * 0.2;       // CO em mg/m³&#10;    float umidade = analogRead(A4) * 0.09; // Umidade em %&#10;&#10;    // Envia JSON com dados dos sensores&#10;    Serial.print(&quot;{\&quot;pm25\&quot;:&quot;);&#10;    Serial.print(pm25, 2);&#10;    Serial.print(&quot;,\&quot;no2\&quot;:&quot;);&#10;    Serial.print(no2, 2);&#10;    Serial.print(&quot;,\&quot;o3\&quot;:&quot;);&#10;    Serial.print(o3, 2);&#10;    Serial.print(&quot;,\&quot;co\&quot;:&quot;);&#10;    Serial.print(co, 2);&#10;    Serial.print(&quot;,\&quot;umidade\&quot;:&quot;);&#10;    Serial.print(umidade, 2);&#10;    Serial.println(&quot;}&quot;);&#10;&#10;    // Processa recomendações recebidas via serial&#10;    if (stringComplete) {&#10;        processarRecomendacoes(inputString);&#10;        inputString = &quot;&quot;;&#10;        stringComplete = false;&#10;    }&#10;&#10;    delay(2000); // Aguarda 2 segundos&#10;}&#10;&#10;// Função chamada automaticamente quando chega dados na serial&#10;void serialEvent() {&#10;    while (Serial.available()) {&#10;        char inChar = (char)Serial.read();&#10;        inputString += inChar;&#10;        if (inChar == '\n') {&#10;            stringComplete = true;&#10;        }&#10;    }&#10;}&#10;&#10;// Processa JSON de recomendações recebido&#10;void processarRecomendacoes(String json) {&#10;    // Parse simples do JSON (ou use biblioteca ArduinoJson para JSON complexo)&#10;    boolean fechar_janelas = json.indexOf(&quot;\&quot;fechar_janelas\&quot;:true&quot;) &gt; 0;&#10;    boolean ativar_purificador = json.indexOf(&quot;\&quot;ativar_purificador\&quot;:true&quot;) &gt; 0;&#10;    boolean usar_mascaras = json.indexOf(&quot;\&quot;usar_mascaras\&quot;:true&quot;) &gt; 0;&#10;    boolean se_hidratar = json.indexOf(&quot;\&quot;sehidratar_controlar_humidade\&quot;:true&quot;) &gt; 0;&#10;    &#10;    // Extrai tempo_categoria (0, 1, 2 ou 3)&#10;    int tempo_categoria = 0;&#10;    int idx = json.indexOf(&quot;\&quot;tempo_categoria\&quot;:&quot;);&#10;    if (idx &gt; 0) {&#10;        tempo_categoria = json.substring(idx + 18, idx + 19).toInt();&#10;    }&#10;    &#10;    // Aciona LEDs/Relés conforme as recomendações&#10;    digitalWrite(LED_FECHAR_JANELAS, fechar_janelas ? HIGH : LOW);&#10;    digitalWrite(LED_ATIVAR_PURIFICADOR, ativar_purificador ? HIGH : LOW);&#10;    digitalWrite(LED_USAR_MASCARAS, usar_mascaras ? HIGH : LOW);&#10;    digitalWrite(LED_SE_HIDRATAR, se_hidratar ? HIGH : LOW);&#10;    &#10;    // LED de urgência pisca conforme tempo_categoria&#10;    // 0=Desligado, 1=Lento, 2=Médio, 3=Rápido&#10;    if (tempo_categoria == 0) {&#10;        digitalWrite(LED_TEMPO_CATEGORIA, LOW);&#10;    } else if (tempo_categoria &gt;= 2) {&#10;        digitalWrite(LED_TEMPO_CATEGORIA, HIGH); // Urgente = sempre ligado&#10;    } else {&#10;        // Pisca lento para categoria 1&#10;        digitalWrite(LED_TEMPO_CATEGORIA, millis() % 1000 &lt; 500 ? HIGH : LOW);&#10;    }&#10;    &#10;    // Debug: imprime status&#10;    Serial.print(&quot;&gt;&gt; Janelas:&quot;);&#10;    Serial.print(fechar_janelas);&#10;    Serial.print(&quot; Purif:&quot;);&#10;    Serial.print(ativar_purificador);&#10;    Serial.print(&quot; Mask:&quot;);&#10;    Serial.print(usar_mascaras);&#10;    Serial.print(&quot; Hidr:&quot;);&#10;    Serial.print(se_hidratar);&#10;    Serial.print(&quot; Tempo:&quot;);&#10;    Serial.println(tempo_categoria);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/trataDadosClimaticos.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/trataDadosClimaticos.js" />
              <option name="originalContent" value="const axios = require('axios');&#10;&#10;const LIMITES = {&#10;    PM25: 15,  // µg/m³&#10;    NO2: 200,&#10;    O3: 180,&#10;    CO: 10,&#10;    UMIDADE_MIN: 40,&#10;    UMIDADE_MAX: 60&#10;};&#10;&#10;let ultimaRecomendacao = {&#10;    fechar_janelas: false,&#10;    ativar_purificador: false,&#10;    usar_mascaras: false,&#10;    controlar_umidade: false,&#10;    tempo_para_pico: 0&#10;};&#10;&#10;// Configurações da API Meteomatics&#10;const USERNAME = process.env.METEOMATICS_USER || 'lima_caique';&#10;const PASSWORD = process.env.METEOMATICS_PASS || 'py01s7YnAEAc14VEM952';&#10;&#10;// Localização padrão (será substituída por geocodificação)&#10;let localizacaoAtual = {&#10;    nome: process.env.LOCALIZACAO || 'São Paulo, SP, Brasil',&#10;    lat: '-23.5505',&#10;    lon: '-46.6333'&#10;};&#10;&#10;/**&#10; * Converte nome de localização em coordenadas usando API de geocodificação&#10; * @param {string} local - Nome da cidade/endereço&#10; * @returns {Promise&lt;Object&gt;} - {nome, lat, lon}&#10; */&#10;async function obterCoordenadas(local) {&#10;    // Usando OpenStreetMap Nominatim (gratuito e sem necessidade de API key)&#10;    const url = `https://nominatim.openstreetmap.org/search?format=json&amp;q=${encodeURIComponent(local)}&amp;limit=1`;&#10;&#10;    const response = await axios.get(url, {&#10;        headers: {&#10;            'User-Agent': 'AtmosProject/1.0'&#10;        },&#10;        timeout: 5000&#10;    });&#10;&#10;    if (response.data &amp;&amp; response.data.length &gt; 0) {&#10;        const resultado = response.data[0];&#10;        return {&#10;            nome: resultado.display_name,&#10;            lat: resultado.lat,&#10;            lon: resultado.lon&#10;        };&#10;    } else {&#10;        throw new Error(`Localização &quot;${local}&quot; não encontrada`);&#10;    }&#10;}&#10;&#10;/**&#10; * Define a localização atual do sistema&#10; * @param {string} local - Nome da cidade/endereço&#10; */&#10;async function definirLocalizacao(local) {&#10;    try {&#10;        const novaLocalizacao = await obterCoordenadas(local);&#10;        localizacaoAtual = novaLocalizacao;&#10;        console.log(`Localização atualizada: ${novaLocalizacao.nome}`);&#10;        console.log(`Coordenadas: ${novaLocalizacao.lat}, ${novaLocalizacao.lon}`);&#10;&#10;        // Atualiza recomendações para a nova localização&#10;        await atualizarRecomendacoes();&#10;&#10;        return novaLocalizacao;&#10;    } catch (error) {&#10;        throw new Error(`Não foi possível definir localização: ${error.message}`);&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna a localização atual&#10; */&#10;function obterLocalizacaoAtual() {&#10;    return localizacaoAtual;&#10;}&#10;&#10;/**&#10; * Calcula a regressão linear para prever tendência de crescimento do poluente&#10; * @param {Array} dadosPoluente - Array com objetos {timestamp, valor}&#10; * @returns {Object|null} - {slope, intercept} ou null se dados insuficientes&#10; */&#10;function calcularHoraPico(dadosPoluente) {&#10;    const n = dadosPoluente.length;&#10;    if (n &lt; 2) return null;&#10;&#10;    const y = dadosPoluente.map(d =&gt; d.valor);&#10;&#10;    // Otimização: calcular médias uma única vez&#10;    const yMedia = y.reduce((a, b) =&gt; a + b, 0) / n;&#10;    const xMedia = (n - 1) / 2; // Média de índices 0..n-1&#10;&#10;    let numer = 0, denom = 0;&#10;    for (let i = 0; i &lt; n; i++) {&#10;        const xDiff = i - xMedia;&#10;        numer += xDiff * (y[i] - yMedia);&#10;        denom += xDiff * xDiff;&#10;    }&#10;&#10;    if (denom === 0) return null;&#10;&#10;    const slope = numer / denom;&#10;    const intercept = yMedia - slope * xMedia;&#10;&#10;    return { slope, intercept };&#10;}&#10;&#10;/**&#10; * Calcula recomendações baseadas nos dados de poluentes e umidade&#10; * @param {Object} dados - Objeto com arrays de dados por poluente&#10; * @returns {Object} - Recomendações calculadas com horário de pico&#10; */&#10;function calcularRecomendacoes(dados) {&#10;    const poluentes = ['PM25', 'NO2', 'O3', 'CO'];&#10;    let tempoHorasMin = null;&#10;    let poluenteCritico = null;&#10;    const previsoesPoluentes = {};&#10;&#10;    // Calcula tempo para atingir limite crítico e horário de pico para cada poluente&#10;    for (let poluente of poluentes) {&#10;        if (!dados[poluente] || dados[poluente].length === 0) continue;&#10;&#10;        const valorAtual = dados[poluente][0].valor;&#10;        const result = calcularHoraPico(dados[poluente]);&#10;&#10;        previsoesPoluentes[poluente] = {&#10;            valor_atual: valorAtual,&#10;            limite: LIMITES[poluente],&#10;            tendencia: null,&#10;            horas_para_limite: null,&#10;            horario_pico: null,&#10;            valores_previstos: dados[poluente].slice(0, 6).map(d =&gt; ({&#10;                horario: new Date(d.timestamp).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),&#10;                valor: Math.round(d.valor * 10) / 10&#10;            }))&#10;        };&#10;&#10;        if (!result) continue;&#10;&#10;        const { slope } = result;&#10;        const limite = LIMITES[poluente];&#10;&#10;        // Define tendência&#10;        if (slope &gt; 0.5) previsoesPoluentes[poluente].tendencia = 'crescente';&#10;        else if (slope &lt; -0.5) previsoesPoluentes[poluente].tendencia = 'decrescente';&#10;        else previsoesPoluentes[poluente].tendencia = 'estável';&#10;&#10;        // Se está crescendo, calcula quando vai atingir o limite&#10;        if (slope &gt; 0) {&#10;            const horasParaLimite = (limite - valorAtual) / slope;&#10;&#10;            if (horasParaLimite &gt;= 0) {&#10;                const horarioPico = new Date(Date.now() + horasParaLimite * 60 * 60 * 1000);&#10;                previsoesPoluentes[poluente].horas_para_limite = Math.round(horasParaLimite * 10) / 10;&#10;                previsoesPoluentes[poluente].horario_pico = horarioPico.toLocaleString('pt-BR', {&#10;                    day: '2-digit',&#10;                    month: '2-digit',&#10;                    hour: '2-digit',&#10;                    minute: '2-digit'&#10;                });&#10;&#10;                if (tempoHorasMin === null || horasParaLimite &lt; tempoHorasMin) {&#10;                    tempoHorasMin = horasParaLimite;&#10;                    poluenteCritico = poluente;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Categoriza o tempo para pico e nível de alerta&#10;    let tempo_categoria = 0;&#10;    let nivel_alerta = 'BOM';&#10;    let mensagem_alerta = 'Qualidade do ar em níveis aceitáveis';&#10;&#10;    if (tempoHorasMin !== null) {&#10;        if (tempoHorasMin &lt;= 3) {&#10;            tempo_categoria = 3;&#10;            nivel_alerta = 'CRÍTICO';&#10;            mensagem_alerta = `ATENÇÃO: ${poluenteCritico} atingirá nível crítico em menos de 3 horas!`;&#10;        } else if (tempoHorasMin &lt;= 6) {&#10;            tempo_categoria = 2;&#10;            nivel_alerta = 'ALTO';&#10;            mensagem_alerta = `ALERTA: ${poluenteCritico} atingirá nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else if (tempoHorasMin &lt;= 12) {&#10;            tempo_categoria = 1;&#10;            nivel_alerta = 'MODERADO';&#10;            mensagem_alerta = `Atenção: ${poluenteCritico} pode atingir nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else {&#10;            tempo_categoria = 0;&#10;            nivel_alerta = 'BAIXO';&#10;            mensagem_alerta = `${poluenteCritico} em tendência de crescimento mas ainda seguro`;&#10;        }&#10;    }&#10;&#10;    // Pega valores atuais (primeiro item de cada array)&#10;    const ultimo = {};&#10;    for (let poluente of poluentes) {&#10;        ultimo[poluente] = dados[poluente]?.[0]?.valor || 0;&#10;    }&#10;    const ultimaUmidade = dados['RH_2m']?.[0]?.valor || 50;&#10;&#10;    // Calcula índice de qualidade do ar geral (0-100, quanto menor melhor)&#10;    const indiceQualidade = Math.min(100, Math.round(&#10;        (ultimo.PM25 / LIMITES.PM25 * 30) +&#10;        (ultimo.NO2 / LIMITES.NO2 * 25) +&#10;        (ultimo.O3 / LIMITES.O3 * 25) +&#10;        (ultimo.CO / LIMITES.CO * 20)&#10;    ));&#10;&#10;    return {&#10;        timestamp: new Date().toISOString(),&#10;        nivel_alerta,&#10;        tempo_categoria,&#10;        mensagem: mensagem_alerta,&#10;        poluente_critico: poluenteCritico,&#10;        tempo_ate_pico: {&#10;            horas: tempoHorasMin ? Math.floor(tempoHorasMin) : null,&#10;            minutos: tempoHorasMin ? Math.round((tempoHorasMin % 1) * 60) : null,&#10;            horario_estimado: tempoHorasMin ? new Date(Date.now() + tempoHorasMin * 60 * 60 * 1000).toLocaleString('pt-BR') : null&#10;        },&#10;        indice_qualidade_ar: {&#10;            valor: indiceQualidade,&#10;            categoria: indiceQualidade &lt; 25 ? 'BOM' : indiceQualidade &lt; 50 ? 'REGULAR' : indiceQualidade &lt; 75 ? 'RUIM' : 'PÉSSIMO'&#10;        },&#10;        valores_atuais: ultimo,&#10;        umidade_atual: ultimaUmidade,&#10;        previsoes_por_poluente: previsoesPoluentes,&#10;        recomendacoes: {&#10;            fechar_janelas: ultimo.PM25 &gt; LIMITES.PM25 || ultimo.NO2 &gt; LIMITES.NO2,&#10;            ativar_purificador: ultimo.PM25 &gt; 35 || ultimo.O3 &gt; 70,&#10;            usar_mascaras: ultimo.PM25 &gt; 55 || ultimo.CO &gt; LIMITES.CO,&#10;            'se_hidratar-Controlar_humidade': (ultimaUmidade &lt; LIMITES.UMIDADE_MIN || ultimaUmidade &gt; LIMITES.UMIDADE_MAX) || (nivel_alerta === 'CRÍTICO' || nivel_alerta === 'ALTO')&#10;        }&#10;    };&#10;}&#10;&#10;/**&#10; * Busca dados da API e atualiza recomendações&#10; */&#10;async function atualizarRecomendacoes() {&#10;    try {&#10;        const agora = new Date();&#10;        const futuro = new Date(agora.getTime() + 12 * 60 * 60 * 1000);&#10;        const agoraISO = agora.toISOString();&#10;        const futuroISO = futuro.toISOString();&#10;&#10;        // Variáveis corretas da API Meteomatics&#10;        // PM2.5 em µg/m³, NO2 em µg/m³, O3 em µg/m³, CO em mg/m³, Umidade em %&#10;        const variaveis = [&#10;            'pm2p5:ugm3',           // PM2.5 em µg/m³&#10;            'no2:ugm3',              // NO2 em µg/m³&#10;            'o3:ugm3',               // O3 em µg/m³&#10;            'co:ugm3',               // CO em ug/m³&#10;            'relative_humidity_2m:p'           // Umidade relativa em %&#10;        ];&#10;&#10;        const url = `https://api.meteomatics.com/${agoraISO}--${futuroISO}:PT1H/${variaveis.join(',')}/${localizacaoAtual.lat},${localizacaoAtual.lon}/json?model=mix`;&#10;&#10;        console.log(`Buscando dados da API Meteomatics para: ${localizacaoAtual.nome}...`);&#10;&#10;        const response = await axios.get(url, {&#10;            auth: { username: USERNAME, password: PASSWORD },&#10;            timeout: 15000&#10;        });&#10;&#10;        // Processa dados da API Meteomatics&#10;        const dados = {};&#10;&#10;        if (response.data &amp;&amp; response.data.data) {&#10;            for (let variavel of response.data.data) {&#10;                let nome = variavel.parameter;&#10;&#10;                // Mapeia nomes da API para nomes internos&#10;                if (nome.includes('pm2p5') || nome.includes('PM2.5')) nome = 'PM25';&#10;                else if (nome.includes('no2') || nome.includes('NO2')) nome = 'NO2';&#10;                else if (nome.includes('o3') || nome.includes('O3')) nome = 'O3';&#10;                else if (nome.includes('co') || nome.includes('CO')) nome = 'CO';&#10;                else if (nome.includes('relative_humidity')) nome = 'RH_2m';&#10;                else continue; // Ignora variáveis não reconhecidas&#10;&#10;                // Extrai os dados da estrutura da API&#10;                if (variavel.coordinates &amp;&amp; variavel.coordinates[0] &amp;&amp; variavel.coordinates[0].dates) {&#10;                    dados[nome] = variavel.coordinates[0].dates.map(d =&gt; ({&#10;                        timestamp: d.date,&#10;                        valor: d.value&#10;                    }));&#10;                }&#10;            }&#10;        }&#10;&#10;        // Verifica se conseguiu dados suficientes&#10;        if (Object.keys(dados).length &gt; 0) {&#10;            ultimaRecomendacao = calcularRecomendacoes(dados);&#10;            ultimaRecomendacao.localizacao = localizacaoAtual.nome;&#10;            console.log(`[${new Date().toLocaleTimeString()}] Recomendação atualizada:`, ultimaRecomendacao);&#10;        } else {&#10;            console.warn('Nenhum dado válido recebido da API');&#10;        }&#10;&#10;    } catch (error) {&#10;        console.error('Erro ao atualizar recomendação:', error.response?.data || error.message);&#10;&#10;        // Mantém última recomendação válida em caso de erro&#10;        if (!ultimaRecomendacao.valores_atuais) {&#10;            ultimaRecomendacao = {&#10;                ...ultimaRecomendacao,&#10;                erro: 'Dados indisponíveis temporariamente'&#10;            };&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna as recomendações atuais&#10; */&#10;function obterRecomendacoes() {&#10;    return ultimaRecomendacao;&#10;}&#10;&#10;/**&#10; * Inicializa o sistema de monitoramento&#10; */&#10;async function inicializar() {&#10;    console.log('Iniciando sistema de monitoramento de qualidade do ar...');&#10;    atualizarRecomendacoes();&#10;    // Atualiza a cada 10 minutos&#10;    setInterval(atualizarRecomendacoes, 10 * 60 * 1000);&#10;}&#10;&#10;module.exports = {&#10;    inicializar,&#10;    obterRecomendacoes,&#10;    calcularRecomendacoes,&#10;    calcularHoraPico,&#10;    definirLocalizacao,&#10;    obterLocalizacaoAtual,&#10;    obterCoordenadas,&#10;    LIMITES&#10;};" />
              <option name="updatedContent" value="const axios = require('axios');&#10;const arduino = require('../arduino/arduino');&#10;&#10;const LIMITES = {&#10;    PM25: 15,  // µg/m³&#10;    NO2: 200,&#10;    O3: 180,&#10;    CO: 10,&#10;    UMIDADE_MIN: 40,&#10;    UMIDADE_MAX: 60&#10;};&#10;&#10;let ultimaRecomendacao = {&#10;    fechar_janelas: false,&#10;    ativar_purificador: false,&#10;    usar_mascaras: false,&#10;    controlar_umidade: false,&#10;    tempo_para_pico: 0&#10;};&#10;&#10;// Configurações da API Meteomatics&#10;const USERNAME = process.env.METEOMATICS_USER || 'lima_caique';&#10;const PASSWORD = process.env.METEOMATICS_PASS || 'py01s7YnAEAc14VEM952';&#10;&#10;// Localização padrão (será substituída por geocodificação)&#10;let localizacaoAtual = {&#10;    nome: process.env.LOCALIZACAO || 'São Paulo, SP, Brasil',&#10;    lat: '-23.5505',&#10;    lon: '-46.6333'&#10;};&#10;&#10;/**&#10; * Converte nome de localização em coordenadas usando API de geocodificação&#10; * @param {string} local - Nome da cidade/endereço&#10; * @returns {Promise&lt;Object&gt;} - {nome, lat, lon}&#10; */&#10;async function obterCoordenadas(local) {&#10;    // Usando OpenStreetMap Nominatim (gratuito e sem necessidade de API key)&#10;    const url = `https://nominatim.openstreetmap.org/search?format=json&amp;q=${encodeURIComponent(local)}&amp;limit=1`;&#10;&#10;    const response = await axios.get(url, {&#10;        headers: {&#10;            'User-Agent': 'AtmosProject/1.0'&#10;        },&#10;        timeout: 5000&#10;    });&#10;&#10;    if (response.data &amp;&amp; response.data.length &gt; 0) {&#10;        const resultado = response.data[0];&#10;        return {&#10;            nome: resultado.display_name,&#10;            lat: resultado.lat,&#10;            lon: resultado.lon&#10;        };&#10;    } else {&#10;        throw new Error(`Localização &quot;${local}&quot; não encontrada`);&#10;    }&#10;}&#10;&#10;/**&#10; * Define a localização atual do sistema&#10; * @param {string} local - Nome da cidade/endereço&#10; */&#10;async function definirLocalizacao(local) {&#10;    try {&#10;        const novaLocalizacao = await obterCoordenadas(local);&#10;        localizacaoAtual = novaLocalizacao;&#10;        console.log(`Localização atualizada: ${novaLocalizacao.nome}`);&#10;        console.log(`Coordenadas: ${novaLocalizacao.lat}, ${novaLocalizacao.lon}`);&#10;&#10;        // Atualiza recomendações para a nova localização&#10;        await atualizarRecomendacoes();&#10;&#10;        return novaLocalizacao;&#10;    } catch (error) {&#10;        throw new Error(`Não foi possível definir localização: ${error.message}`);&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna a localização atual&#10; */&#10;function obterLocalizacaoAtual() {&#10;    return localizacaoAtual;&#10;}&#10;&#10;/**&#10; * Calcula a regressão linear para prever tendência de crescimento do poluente&#10; * @param {Array} dadosPoluente - Array com objetos {timestamp, valor}&#10; * @returns {Object|null} - {slope, intercept} ou null se dados insuficientes&#10; */&#10;function calcularHoraPico(dadosPoluente) {&#10;    const n = dadosPoluente.length;&#10;    if (n &lt; 2) return null;&#10;&#10;    const y = dadosPoluente.map(d =&gt; d.valor);&#10;&#10;    // Otimização: calcular médias uma única vez&#10;    const yMedia = y.reduce((a, b) =&gt; a + b, 0) / n;&#10;    const xMedia = (n - 1) / 2; // Média de índices 0..n-1&#10;&#10;    let numer = 0, denom = 0;&#10;    for (let i = 0; i &lt; n; i++) {&#10;        const xDiff = i - xMedia;&#10;        numer += xDiff * (y[i] - yMedia);&#10;        denom += xDiff * xDiff;&#10;    }&#10;&#10;    if (denom === 0) return null;&#10;&#10;    const slope = numer / denom;&#10;    const intercept = yMedia - slope * xMedia;&#10;&#10;    return { slope, intercept };&#10;}&#10;&#10;/**&#10; * Calcula recomendações baseadas nos dados de poluentes e umidade&#10; * @param {Object} dados - Objeto com arrays de dados por poluente&#10; * @returns {Object} - Recomendações calculadas com horário de pico&#10; */&#10;function calcularRecomendacoes(dados) {&#10;    const poluentes = ['PM25', 'NO2', 'O3', 'CO'];&#10;    let tempoHorasMin = null;&#10;    let poluenteCritico = null;&#10;    const previsoesPoluentes = {};&#10;&#10;    // Calcula tempo para atingir limite crítico e horário de pico para cada poluente&#10;    for (let poluente of poluentes) {&#10;        if (!dados[poluente] || dados[poluente].length === 0) continue;&#10;&#10;        const valorAtual = dados[poluente][0].valor;&#10;        const result = calcularHoraPico(dados[poluente]);&#10;&#10;        previsoesPoluentes[poluente] = {&#10;            valor_atual: valorAtual,&#10;            limite: LIMITES[poluente],&#10;            tendencia: null,&#10;            horas_para_limite: null,&#10;            horario_pico: null,&#10;            valores_previstos: dados[poluente].slice(0, 6).map(d =&gt; ({&#10;                horario: new Date(d.timestamp).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),&#10;                valor: Math.round(d.valor * 10) / 10&#10;            }))&#10;        };&#10;&#10;        if (!result) continue;&#10;&#10;        const { slope } = result;&#10;        const limite = LIMITES[poluente];&#10;&#10;        // Define tendência&#10;        if (slope &gt; 0.5) previsoesPoluentes[poluente].tendencia = 'crescente';&#10;        else if (slope &lt; -0.5) previsoesPoluentes[poluente].tendencia = 'decrescente';&#10;        else previsoesPoluentes[poluente].tendencia = 'estável';&#10;&#10;        // Se está crescendo, calcula quando vai atingir o limite&#10;        if (slope &gt; 0) {&#10;            const horasParaLimite = (limite - valorAtual) / slope;&#10;&#10;            if (horasParaLimite &gt;= 0) {&#10;                const horarioPico = new Date(Date.now() + horasParaLimite * 60 * 60 * 1000);&#10;                previsoesPoluentes[poluente].horas_para_limite = Math.round(horasParaLimite * 10) / 10;&#10;                previsoesPoluentes[poluente].horario_pico = horarioPico.toLocaleString('pt-BR', {&#10;                    day: '2-digit',&#10;                    month: '2-digit',&#10;                    hour: '2-digit',&#10;                    minute: '2-digit'&#10;                });&#10;&#10;                if (tempoHorasMin === null || horasParaLimite &lt; tempoHorasMin) {&#10;                    tempoHorasMin = horasParaLimite;&#10;                    poluenteCritico = poluente;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Categoriza o tempo para pico e nível de alerta&#10;    let tempo_categoria = 0;&#10;    let nivel_alerta = 'BOM';&#10;    let mensagem_alerta = 'Qualidade do ar em níveis aceitáveis';&#10;&#10;    if (tempoHorasMin !== null) {&#10;        if (tempoHorasMin &lt;= 3) {&#10;            tempo_categoria = 3;&#10;            nivel_alerta = 'CRÍTICO';&#10;            mensagem_alerta = `ATENÇÃO: ${poluenteCritico} atingirá nível crítico em menos de 3 horas!`;&#10;        } else if (tempoHorasMin &lt;= 6) {&#10;            tempo_categoria = 2;&#10;            nivel_alerta = 'ALTO';&#10;            mensagem_alerta = `ALERTA: ${poluenteCritico} atingirá nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else if (tempoHorasMin &lt;= 12) {&#10;            tempo_categoria = 1;&#10;            nivel_alerta = 'MODERADO';&#10;            mensagem_alerta = `Atenção: ${poluenteCritico} pode atingir nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else {&#10;            tempo_categoria = 0;&#10;            nivel_alerta = 'BAIXO';&#10;            mensagem_alerta = `${poluenteCritico} em tendência de crescimento mas ainda seguro`;&#10;        }&#10;    }&#10;&#10;    // Pega valores atuais (primeiro item de cada array)&#10;    const ultimo = {};&#10;    for (let poluente of poluentes) {&#10;        ultimo[poluente] = dados[poluente]?.[0]?.valor || 0;&#10;    }&#10;    const ultimaUmidade = dados['RH_2m']?.[0]?.valor || 50;&#10;&#10;    // Calcula índice de qualidade do ar geral (0-100, quanto menor melhor)&#10;    const indiceQualidade = Math.min(100, Math.round(&#10;        (ultimo.PM25 / LIMITES.PM25 * 30) +&#10;        (ultimo.NO2 / LIMITES.NO2 * 25) +&#10;        (ultimo.O3 / LIMITES.O3 * 25) +&#10;        (ultimo.CO / LIMITES.CO * 20)&#10;    ));&#10;&#10;    return {&#10;        timestamp: new Date().toISOString(),&#10;        nivel_alerta,&#10;        tempo_categoria,&#10;        mensagem: mensagem_alerta,&#10;        poluente_critico: poluenteCritico,&#10;        tempo_ate_pico: {&#10;            horas: tempoHorasMin ? Math.floor(tempoHorasMin) : null,&#10;            minutos: tempoHorasMin ? Math.round((tempoHorasMin % 1) * 60) : null,&#10;            horario_estimado: tempoHorasMin ? new Date(Date.now() + tempoHorasMin * 60 * 60 * 1000).toLocaleString('pt-BR') : null&#10;        },&#10;        indice_qualidade_ar: {&#10;            valor: indiceQualidade,&#10;            categoria: indiceQualidade &lt; 25 ? 'BOM' : indiceQualidade &lt; 50 ? 'REGULAR' : indiceQualidade &lt; 75 ? 'RUIM' : 'PÉSSIMO'&#10;        },&#10;        valores_atuais: ultimo,&#10;        umidade_atual: ultimaUmidade,&#10;        previsoes_por_poluente: previsoesPoluentes,&#10;        recomendacoes: {&#10;            fechar_janelas: ultimo.PM25 &gt; LIMITES.PM25 || ultimo.NO2 &gt; LIMITES.NO2,&#10;            ativar_purificador: ultimo.PM25 &gt; 35 || ultimo.O3 &gt; 70,&#10;            usar_mascaras: ultimo.PM25 &gt; 55 || ultimo.CO &gt; LIMITES.CO,&#10;            'se_hidratar-Controlar_humidade': (ultimaUmidade &lt; LIMITES.UMIDADE_MIN || ultimaUmidade &gt; LIMITES.UMIDADE_MAX) || (nivel_alerta === 'CRÍTICO' || nivel_alerta === 'ALTO')&#10;        }&#10;    };&#10;}&#10;&#10;/**&#10; * Busca dados do Arduino e atualiza recomendações&#10; */&#10;async function atualizarRecomendacoes() {&#10;    try {&#10;        const dadosArduino = arduino.obterDados();&#10;&#10;        if (!dadosArduino) {&#10;            console.warn('⏳ Aguardando dados do Arduino...');&#10;            return;&#10;        }&#10;&#10;        // Monta estrutura compatível com calcularRecomendacoes&#10;        const dados = {&#10;            PM25: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.pm25 || 0 }],&#10;            NO2: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.no2 || 0 }],&#10;            O3: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.o3 || 0 }],&#10;            CO: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.co || 0 }],&#10;            RH_2m: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.umidade || 50 }]&#10;        };&#10;&#10;        ultimaRecomendacao = calcularRecomendacoes(dados);&#10;        ultimaRecomendacao.localizacao = 'Local (Arduino)';&#10;        console.log(`[${new Date().toLocaleTimeString()}] ✅ Recomendação atualizada`);&#10;&#10;        // Envia as recomendações de volta para o Arduino&#10;        if (ultimaRecomendacao.recomendacoes) {&#10;            arduino.enviarRecomendacoes(ultimaRecomendacao.recomendacoes);&#10;        }&#10;&#10;    } catch (error) {&#10;        console.error('Erro ao atualizar recomendação:', error.message);&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna as recomendações atuais&#10; */&#10;function obterRecomendacoes() {&#10;    return ultimaRecomendacao;&#10;}&#10;&#10;/**&#10; * Inicializa o sistema de monitoramento&#10; */&#10;async function inicializar() {&#10;    console.log(' Iniciando sistema via Arduino...');&#10;    arduino.conectar();&#10;&#10;    // Aguarda 3 segundos antes da primeira leitura&#10;    setTimeout(() =&gt; {&#10;        atualizarRecomendacoes();&#10;        setInterval(atualizarRecomendacoes, 10000); // A cada 10 segundos&#10;    }, 3000);&#10;}&#10;&#10;module.exports = {&#10;    inicializar,&#10;    obterRecomendacoes,&#10;    calcularRecomendacoes,&#10;    calcularHoraPico,&#10;    definirLocalizacao,&#10;    obterLocalizacaoAtual,&#10;    obterCoordenadas,&#10;    LIMITES&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>