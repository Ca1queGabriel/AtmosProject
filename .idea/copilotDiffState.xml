<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.env.example">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.env.example" />
              <option name="updatedContent" value="# Configuração da porta serial do Arduino&#10;ARDUINO_PORT=COM3&#10;&#10;# Para Linux/Mac use algo como:&#10;# ARDUINO_PORT=/dev/ttyUSB0&#10;# ARDUINO_PORT=/dev/ttyACM0&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app.js" />
              <option name="originalContent" value="console.log(&quot;Peixe&quot;);&#10;var createError = require('http-errors');&#10;var express = require('express');&#10;var climaRouter = require('./routes/clima');&#10;var path = require('path');&#10;const axios = require('axios');&#10;&#10;var cookieParser = require('cookie-parser');&#10;var logger = require('morgan');&#10;var app = express();&#10;var indexRouter = require('./routes/index');&#10;var usersRouter = require('./routes/users');&#10;const trataDados = require('./scripts/trataDadosClimaticos');&#10;const arduino = require('./arduino/arduino');&#10;&#10;// Inicializa o sistema de monitoramento&#10;trataDados.inicializar();&#10;&#10;&#10;app.use('/clima', climaRouter);&#10;&#10;// Rota para status do Arduino&#10;app.get('/arduino-status', (req, res) =&gt; {&#10;    const dados = arduino.obterDados();&#10;    res.json({&#10;        conectado: dados !== null,&#10;        ultima_leitura: dados&#10;    });&#10;});&#10;&#10;app.get(&quot;/teste&quot;, (req, res) =&gt; {&#10;    res.render('index');&#10;})&#10;&#10;// Rota para obter previsão de qualidade do ar&#10;app.get('/previsao-ar', (req, res) =&gt; {&#10;    res.json(trataDados.obterRecomendacoes());&#10;});&#10;&#10;// Rota para definir localização (POST ou GET com query param)&#10;app.post('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.body.local;&#10;        if (!local) {&#10;            return res.status(400).json({ erro: 'Parâmetro &quot;local&quot; é obrigatório' });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota alternativa GET para definir localização&#10;app.get('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.query.local;&#10;        if (!local) {&#10;            return res.status(400).json({&#10;                erro: 'Parâmetro &quot;local&quot; é obrigatório',&#10;                exemplo: '/localizar?local=Sorocaba, SP'&#10;            });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota para obter localização atual&#10;app.get('/localizacao-atual', (req, res) =&gt; {&#10;    res.json(trataDados.obterLocalizacaoAtual());&#10;});&#10;&#10;app.set('views', path.join(__dirname, 'views'));&#10;&#10;app.set('view engine', 'pug');&#10;app.use(logger('dev'));&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;app.use(cookieParser());&#10;&#10;&#10;app.use(express.static(path.join(__dirname, 'public')));&#10;app.use('/users', usersRouter);&#10;app.use('/', indexRouter);&#10;&#10;// catch 404 and forward to error handler&#10;app.use(function(req, res, next) {&#10;  next(createError(404));&#10;});&#10;&#10;// error handler&#10;app.use(function(err, req, res, next) {&#10;  // set locals, only providing error in development&#10;  res.locals.message = err.message;&#10;  res.locals.error = req.app.get('env') === 'development' ? err : {};&#10;&#10;  // render the error page&#10;  res.status(err.status || 500);&#10;  res.render('error');&#10;});&#10;&#10;module.exports = app;" />
              <option name="updatedContent" value="console.log(&quot;Peixe&quot;);&#10;var createError = require('http-errors');&#10;var express = require('express');&#10;var climaRouter = require('./routes/clima');&#10;var path = require('path');&#10;const axios = require('axios');&#10;&#10;var cookieParser = require('cookie-parser');&#10;var logger = require('morgan');&#10;var app = express();&#10;var indexRouter = require('./routes/index');&#10;var usersRouter = require('./routes/users');&#10;const trataDados = require('./scripts/trataDadosClimaticos');&#10;const arduino = require('./arduino/arduino');&#10;&#10;// Inicializa o sistema de monitoramento&#10;trataDados.inicializar();&#10;&#10;&#10;app.use('/clima', climaRouter);&#10;&#10;// Rota para status do Arduino&#10;app.get('/arduino-status', (req, res) =&gt; {&#10;    const dados = arduino.obterDados();&#10;    res.json({&#10;        conectado: dados !== null,&#10;        ultima_leitura: dados&#10;    });&#10;});&#10;&#10;app.get(&quot;/teste&quot;, (req, res) =&gt; {&#10;    res.render('index');&#10;})&#10;&#10;// Rota para obter previsão de qualidade do ar&#10;app.get('/previsao-ar', (req, res) =&gt; {&#10;    res.json(trataDados.obterRecomendacoes());&#10;});&#10;&#10;// Rota para definir localização (POST ou GET com query param)&#10;app.post('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.body.local;&#10;        if (!local) {&#10;            return res.status(400).json({ erro: 'Parâmetro &quot;local&quot; é obrigatório' });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota alternativa GET para definir localização&#10;app.get('/localizar', async (req, res) =&gt; {&#10;    try {&#10;        const local = req.query.local;&#10;        if (!local) {&#10;            return res.status(400).json({&#10;                erro: 'Parâmetro &quot;local&quot; é obrigatório',&#10;                exemplo: '/localizar?local=Sorocaba, SP'&#10;            });&#10;        }&#10;&#10;        const novaLocalizacao = await trataDados.definirLocalizacao(local);&#10;        res.json({&#10;            sucesso: true,&#10;            mensagem: 'Localização atualizada com sucesso',&#10;            localizacao: novaLocalizacao&#10;        });&#10;    } catch (error) {&#10;        res.status(400).json({ erro: error.message });&#10;    }&#10;});&#10;&#10;// Rota para obter localização atual&#10;app.get('/localizacao-atual', (req, res) =&gt; {&#10;    res.json(trataDados.obterLocalizacaoAtual());&#10;});&#10;&#10;app.set('views', path.join(__dirname, 'views'));&#10;&#10;app.set('view engine', 'pug');&#10;app.use(logger('dev'));&#10;app.use(express.json());&#10;app.use(express.urlencoded({ extended: false }));&#10;app.use(cookieParser());&#10;&#10;&#10;app.use(express.static(path.join(__dirname, 'public')));&#10;app.use('/users', usersRouter);&#10;app.use('/', indexRouter);&#10;&#10;// catch 404 and forward to error handler&#10;app.use(function(req, res, next) {&#10;  next(createError(404));&#10;});&#10;&#10;// error handler&#10;app.use(function(err, req, res, next) {&#10;  // set locals, only providing error in development&#10;  res.locals.message = err.message;&#10;  res.locals.error = req.app.get('env') === 'development' ? err : {};&#10;&#10;  // render the error page&#10;  res.status(err.status || 500);&#10;  res.render('error');&#10;});&#10;&#10;module.exports = app;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/arduino/arduino_sketch.ino">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/arduino/arduino_sketch.ino" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="// Sketch Arduino para enviar dados de sensores e receber recomendações&#10;// Sensores conectados nas portas A0-A4&#10;// LEDs/Relés conectados nas portas digitais 8-12&#10;&#10;// Pinos dos LEDs/Relés para as recomendações&#10;#define LED_FECHAR_JANELAS 8&#10;#define LED_ATIVAR_PURIFICADOR 9&#10;#define LED_USAR_MASCARAS 10&#10;#define LED_SE_HIDRATAR 11&#10;#define LED_TEMPO_CATEGORIA 12  // LED indicador de urgência&#10;&#10;String inputString = &quot;&quot;;&#10;boolean stringComplete = false;&#10;&#10;void setup() {&#10;    Serial.begin(9600);&#10;    &#10;    // Configura pinos dos sensores&#10;    pinMode(A0, INPUT); // Sensor PM2.5&#10;    pinMode(A1, INPUT); // Sensor NO2&#10;    pinMode(A2, INPUT); // Sensor O3&#10;    pinMode(A3, INPUT); // Sensor CO&#10;    pinMode(A4, INPUT); // Sensor Umidade&#10;    &#10;    // Configura pinos dos LEDs/Relés como saída&#10;    pinMode(LED_FECHAR_JANELAS, OUTPUT);&#10;    pinMode(LED_ATIVAR_PURIFICADOR, OUTPUT);&#10;    pinMode(LED_USAR_MASCARAS, OUTPUT);&#10;    pinMode(LED_SE_HIDRATAR, OUTPUT);&#10;    pinMode(LED_TEMPO_CATEGORIA, OUTPUT);&#10;    &#10;    // Inicia com todos os LEDs desligados&#10;    digitalWrite(LED_FECHAR_JANELAS, LOW);&#10;    digitalWrite(LED_ATIVAR_PURIFICADOR, LOW);&#10;    digitalWrite(LED_USAR_MASCARAS, LOW);&#10;    digitalWrite(LED_SE_HIDRATAR, LOW);&#10;    digitalWrite(LED_TEMPO_CATEGORIA, LOW);&#10;    &#10;    inputString.reserve(200);&#10;}&#10;&#10;void loop() {&#10;    // Lê valores dos sensores (adapte conforme seus sensores reais)&#10;    float pm25 = analogRead(A0) * 0.1;     // PM2.5 em µg/m³&#10;    float no2 = analogRead(A1) * 0.5;      // NO2 em µg/m³&#10;    float o3 = analogRead(A2) * 0.3;       // O3 em µg/m³&#10;    float co = analogRead(A3) * 0.2;       // CO em mg/m³&#10;    float umidade = analogRead(A4) * 0.09; // Umidade em %&#10;&#10;    // Envia JSON com dados dos sensores&#10;    Serial.print(&quot;{\&quot;pm25\&quot;:&quot;);&#10;    Serial.print(pm25, 2);&#10;    Serial.print(&quot;,\&quot;no2\&quot;:&quot;);&#10;    Serial.print(no2, 2);&#10;    Serial.print(&quot;,\&quot;o3\&quot;:&quot;);&#10;    Serial.print(o3, 2);&#10;    Serial.print(&quot;,\&quot;co\&quot;:&quot;);&#10;    Serial.print(co, 2);&#10;    Serial.print(&quot;,\&quot;umidade\&quot;:&quot;);&#10;    Serial.print(umidade, 2);&#10;    Serial.println(&quot;}&quot;);&#10;&#10;    // Processa recomendações recebidas via serial&#10;    if (stringComplete) {&#10;        processarRecomendacoes(inputString);&#10;        inputString = &quot;&quot;;&#10;        stringComplete = false;&#10;    }&#10;&#10;    delay(2000); // Aguarda 2 segundos&#10;}&#10;&#10;// Função chamada automaticamente quando chega dados na serial&#10;void serialEvent() {&#10;    while (Serial.available()) {&#10;        char inChar = (char)Serial.read();&#10;        inputString += inChar;&#10;        if (inChar == '\n') {&#10;            stringComplete = true;&#10;        }&#10;    }&#10;}&#10;&#10;// Processa JSON de recomendações recebido&#10;void processarRecomendacoes(String json) {&#10;    // Parse simples do JSON (ou use biblioteca ArduinoJson para JSON complexo)&#10;    boolean fechar_janelas = json.indexOf(&quot;\&quot;fechar_janelas\&quot;:true&quot;) &gt; 0;&#10;    boolean ativar_purificador = json.indexOf(&quot;\&quot;ativar_purificador\&quot;:true&quot;) &gt; 0;&#10;    boolean usar_mascaras = json.indexOf(&quot;\&quot;usar_mascaras\&quot;:true&quot;) &gt; 0;&#10;    boolean se_hidratar = json.indexOf(&quot;\&quot;sehidratar_controlar_humidade\&quot;:true&quot;) &gt; 0;&#10;    &#10;    // Extrai tempo_categoria (0, 1, 2 ou 3)&#10;    int tempo_categoria = 0;&#10;    int idx = json.indexOf(&quot;\&quot;tempo_categoria\&quot;:&quot;);&#10;    if (idx &gt; 0) {&#10;        tempo_categoria = json.substring(idx + 18, idx + 19).toInt();&#10;    }&#10;    &#10;    // Aciona LEDs/Relés conforme as recomendações&#10;    digitalWrite(LED_FECHAR_JANELAS, fechar_janelas ? HIGH : LOW);&#10;    digitalWrite(LED_ATIVAR_PURIFICADOR, ativar_purificador ? HIGH : LOW);&#10;    digitalWrite(LED_USAR_MASCARAS, usar_mascaras ? HIGH : LOW);&#10;    digitalWrite(LED_SE_HIDRATAR, se_hidratar ? HIGH : LOW);&#10;    &#10;    // LED de urgência pisca conforme tempo_categoria&#10;    // 0=Desligado, 1=Lento, 2=Médio, 3=Rápido&#10;    if (tempo_categoria == 0) {&#10;        digitalWrite(LED_TEMPO_CATEGORIA, LOW);&#10;    } else if (tempo_categoria &gt;= 2) {&#10;        digitalWrite(LED_TEMPO_CATEGORIA, HIGH); // Urgente = sempre ligado&#10;    } else {&#10;        // Pisca lento para categoria 1&#10;        digitalWrite(LED_TEMPO_CATEGORIA, millis() % 1000 &lt; 500 ? HIGH : LOW);&#10;    }&#10;    &#10;    // Debug: imprime status&#10;    Serial.print(&quot;&gt;&gt; Janelas:&quot;);&#10;    Serial.print(fechar_janelas);&#10;    Serial.print(&quot; Purif:&quot;);&#10;    Serial.print(ativar_purificador);&#10;    Serial.print(&quot; Mask:&quot;);&#10;    Serial.print(usar_mascaras);&#10;    Serial.print(&quot; Hidr:&quot;);&#10;    Serial.print(se_hidratar);&#10;    Serial.print(&quot; Tempo:&quot;);&#10;    Serial.println(tempo_categoria);&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/scripts/trataDadosClimaticos.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/scripts/trataDadosClimaticos.js" />
              <option name="originalContent" value="const axios = require('axios');&#10;const arduino = require('../arduino/arduino');&#10;&#10;const LIMITES = {&#10;    PM25: 15,  // µg/m³&#10;    NO2: 200,&#10;    O3: 180,&#10;    CO: 10,&#10;    UMIDADE_MIN: 40,&#10;    UMIDADE_MAX: 60&#10;};&#10;&#10;let ultimaRecomendacao = {&#10;    fechar_janelas: false,&#10;    ativar_purificador: false,&#10;    usar_mascaras: false,&#10;    controlar_umidade: false,&#10;    tempo_para_pico: 0&#10;};&#10;&#10;// Configurações da API Meteomatics&#10;const USERNAME = process.env.METEOMATICS_USER || 'lima_caique';&#10;const PASSWORD = process.env.METEOMATICS_PASS || 'py01s7YnAEAc14VEM952';&#10;&#10;// Localização será detectada automaticamente via IP&#10;let localizacaoAtual = null;&#10;&#10;/**&#10; * Detecta automaticamente a localização do usuário usando API de geolocalização por IP&#10; * @returns {Promise&lt;Object&gt;} - {nome, lat, lon, cidade, pais, ip}&#10; */&#10;async function detectarLocalizacaoPorIP() {&#10;    try {&#10;        // Usando ipapi.co - API gratuita e confiável&#10;        const response = await axios.get('https://ipapi.co/json/', {&#10;            timeout: 5000&#10;        });&#10;&#10;        if (response.data) {&#10;            const dados = response.data;&#10;            return {&#10;                nome: `${dados.city}, ${dados.region}, ${dados.country_name}`,&#10;                lat: dados.latitude.toString(),&#10;                lon: dados.longitude.toString(),&#10;                cidade: dados.city,&#10;                regiao: dados.region,&#10;                pais: dados.country_name,&#10;                codigo_pais: dados.country_code,&#10;                ip: dados.ip&#10;            };&#10;        } else {&#10;            throw new Error('Não foi possível obter dados de localização');&#10;        }&#10;    } catch (error) {&#10;        console.error('Erro ao detectar localização por IP:', error.message);&#10;        // Fallback para São Paulo caso falhe&#10;        console.warn('⚠️ Usando localização padrão (São Paulo)');&#10;        return {&#10;            nome: 'São Paulo, SP, Brasil',&#10;            lat: '-23.5505',&#10;            lon: '-46.6333',&#10;            cidade: 'São Paulo',&#10;            regiao: 'SP',&#10;            pais: 'Brasil',&#10;            codigo_pais: 'BR',&#10;            ip: 'desconhecido'&#10;        };&#10;    }&#10;}&#10;&#10;/**&#10; * Converte nome de localização em coordenadas usando API de geocodificação&#10; * @param {string} local - Nome da cidade/endereço&#10; * @returns {Promise&lt;Object&gt;} - {nome, lat, lon}&#10; */&#10;async function obterCoordenadas(local) {&#10;    // Usando OpenStreetMap Nominatim (gratuito e sem necessidade de API key)&#10;    const url = `https://nominatim.openstreetmap.org/search?format=json&amp;q=${encodeURIComponent(local)}&amp;limit=1`;&#10;&#10;    const response = await axios.get(url, {&#10;        headers: {&#10;            'User-Agent': 'AtmosProject/1.0'&#10;        },&#10;        timeout: 5000&#10;    });&#10;&#10;    if (response.data &amp;&amp; response.data.length &gt; 0) {&#10;        const resultado = response.data[0];&#10;        return {&#10;            nome: resultado.display_name,&#10;            lat: resultado.lat,&#10;            lon: resultado.lon&#10;        };&#10;    } else {&#10;        throw new Error(`Localização &quot;${local}&quot; não encontrada`);&#10;    }&#10;}&#10;&#10;/**&#10; * Define a localização atual do sistema&#10; * @param {string} local - Nome da cidade/endereço&#10; */&#10;async function definirLocalizacao(local) {&#10;    try {&#10;        const novaLocalizacao = await obterCoordenadas(local);&#10;        localizacaoAtual = novaLocalizacao;&#10;        console.log(`Localização atualizada: ${novaLocalizacao.nome}`);&#10;        console.log(`Coordenadas: ${novaLocalizacao.lat}, ${novaLocalizacao.lon}`);&#10;&#10;        // Atualiza recomendações para a nova localização&#10;        await atualizarRecomendacoes();&#10;&#10;        return novaLocalizacao;&#10;    } catch (error) {&#10;        throw new Error(`Não foi possível definir localização: ${error.message}`);&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna a localização atual&#10; */&#10;function obterLocalizacaoAtual() {&#10;    return localizacaoAtual;&#10;}&#10;&#10;/**&#10; * Calcula a regressão linear para prever tendência de crescimento do poluente&#10; * @param {Array} dadosPoluente - Array com objetos {timestamp, valor}&#10; * @returns {Object|null} - {slope, intercept} ou null se dados insuficientes&#10; */&#10;function calcularHoraPico(dadosPoluente) {&#10;    const n = dadosPoluente.length;&#10;    if (n &lt; 2) return null;&#10;&#10;    const y = dadosPoluente.map(d =&gt; d.valor);&#10;&#10;    // Otimização: calcular médias uma única vez&#10;    const yMedia = y.reduce((a, b) =&gt; a + b, 0) / n;&#10;    const xMedia = (n - 1) / 2; // Média de índices 0..n-1&#10;&#10;    let numer = 0, denom = 0;&#10;    for (let i = 0; i &lt; n; i++) {&#10;        const xDiff = i - xMedia;&#10;        numer += xDiff * (y[i] - yMedia);&#10;        denom += xDiff * xDiff;&#10;    }&#10;&#10;    if (denom === 0) return null;&#10;&#10;    const slope = numer / denom;&#10;    const intercept = yMedia - slope * xMedia;&#10;&#10;    return { slope, intercept };&#10;}&#10;&#10;/**&#10; * Calcula recomendações baseadas nos dados de poluentes e umidade&#10; * @param {Object} dados - Objeto com arrays de dados por poluente&#10; * @returns {Object} - Recomendações calculadas com horário de pico&#10; */&#10;function calcularRecomendacoes(dados) {&#10;    const poluentes = ['PM25', 'NO2', 'O3', 'CO'];&#10;    let tempoHorasMin = null;&#10;    let poluenteCritico = null;&#10;    const previsoesPoluentes = {};&#10;&#10;    // Calcula tempo para atingir limite crítico e horário de pico para cada poluente&#10;    for (let poluente of poluentes) {&#10;        if (!dados[poluente] || dados[poluente].length === 0) continue;&#10;&#10;        const valorAtual = dados[poluente][0].valor;&#10;        const result = calcularHoraPico(dados[poluente]);&#10;&#10;        previsoesPoluentes[poluente] = {&#10;            valor_atual: valorAtual,&#10;            limite: LIMITES[poluente],&#10;            tendencia: null,&#10;            horas_para_limite: null,&#10;            horario_pico: null,&#10;            valores_previstos: dados[poluente].slice(0, 6).map(d =&gt; ({&#10;                horario: new Date(d.timestamp).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),&#10;                valor: Math.round(d.valor * 10) / 10&#10;            }))&#10;        };&#10;&#10;        if (!result) continue;&#10;&#10;        const { slope } = result;&#10;        const limite = LIMITES[poluente];&#10;&#10;        // Define tendência&#10;        if (slope &gt; 0.5) previsoesPoluentes[poluente].tendencia = 'crescente';&#10;        else if (slope &lt; -0.5) previsoesPoluentes[poluente].tendencia = 'decrescente';&#10;        else previsoesPoluentes[poluente].tendencia = 'estável';&#10;&#10;        // Se está crescendo, calcula quando vai atingir o limite&#10;        if (slope &gt; 0) {&#10;            const horasParaLimite = (limite - valorAtual) / slope;&#10;&#10;            if (horasParaLimite &gt;= 0) {&#10;                const horarioPico = new Date(Date.now() + horasParaLimite * 60 * 60 * 1000);&#10;                previsoesPoluentes[poluente].horas_para_limite = Math.round(horasParaLimite * 10) / 10;&#10;                previsoesPoluentes[poluente].horario_pico = horarioPico.toLocaleString('pt-BR', {&#10;                    day: '2-digit',&#10;                    month: '2-digit',&#10;                    hour: '2-digit',&#10;                    minute: '2-digit'&#10;                });&#10;&#10;                if (tempoHorasMin === null || horasParaLimite &lt; tempoHorasMin) {&#10;                    tempoHorasMin = horasParaLimite;&#10;                    poluenteCritico = poluente;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Categoriza o tempo para pico e nível de alerta&#10;    let tempo_categoria = 0;&#10;    let nivel_alerta = 'BOM';&#10;    let mensagem_alerta = 'Qualidade do ar em níveis aceitáveis';&#10;&#10;    if (tempoHorasMin !== null) {&#10;        if (tempoHorasMin &lt;= 3) {&#10;            tempo_categoria = 3;&#10;            nivel_alerta = 'CRÍTICO';&#10;            mensagem_alerta = `ATENÇÃO: ${poluenteCritico} atingirá nível crítico em menos de 3 horas!`;&#10;        } else if (tempoHorasMin &lt;= 6) {&#10;            tempo_categoria = 2;&#10;            nivel_alerta = 'ALTO';&#10;            mensagem_alerta = `ALERTA: ${poluenteCritico} atingirá nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else if (tempoHorasMin &lt;= 12) {&#10;            tempo_categoria = 1;&#10;            nivel_alerta = 'MODERADO';&#10;            mensagem_alerta = `Atenção: ${poluenteCritico} pode atingir nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else {&#10;            tempo_categoria = 0;&#10;            nivel_alerta = 'BAIXO';&#10;            mensagem_alerta = `${poluenteCritico} em tendência de crescimento mas ainda seguro`;&#10;        }&#10;    }&#10;&#10;    // Pega valores atuais (primeiro item de cada array)&#10;    const ultimo = {};&#10;    for (let poluente of poluentes) {&#10;        ultimo[poluente] = dados[poluente]?.[0]?.valor || 0;&#10;    }&#10;    const ultimaUmidade = dados['RH_2m']?.[0]?.valor || 50;&#10;&#10;    // Calcula índice de qualidade do ar geral (0-100, quanto menor melhor)&#10;    const indiceQualidade = Math.min(100, Math.round(&#10;        (ultimo.PM25 / LIMITES.PM25 * 30) +&#10;        (ultimo.NO2 / LIMITES.NO2 * 25) +&#10;        (ultimo.O3 / LIMITES.O3 * 25) +&#10;        (ultimo.CO / LIMITES.CO * 20)&#10;    ));&#10;&#10;    return {&#10;        timestamp: new Date().toISOString(),&#10;        nivel_alerta,&#10;        tempo_categoria,&#10;        mensagem: mensagem_alerta,&#10;        poluente_critico: poluenteCritico,&#10;        tempo_ate_pico: {&#10;            horas: tempoHorasMin ? Math.floor(tempoHorasMin) : null,&#10;            minutos: tempoHorasMin ? Math.round((tempoHorasMin % 1) * 60) : null,&#10;            horario_estimado: tempoHorasMin ? new Date(Date.now() + tempoHorasMin * 60 * 60 * 1000).toLocaleString('pt-BR') : null&#10;        },&#10;        indice_qualidade_ar: {&#10;            valor: indiceQualidade,&#10;            categoria: indiceQualidade &lt; 25 ? 'BOM' : indiceQualidade &lt; 50 ? 'REGULAR' : indiceQualidade &lt; 75 ? 'RUIM' : 'PÉSSIMO'&#10;        },&#10;        valores_atuais: ultimo,&#10;        umidade_atual: ultimaUmidade,&#10;        previsoes_por_poluente: previsoesPoluentes,&#10;        recomendacoes: {&#10;            fechar_janelas: ultimo.PM25 &gt; LIMITES.PM25 || ultimo.NO2 &gt; LIMITES.NO2,&#10;            ativar_purificador: ultimo.PM25 &gt; 35 || ultimo.O3 &gt; 70,&#10;            usar_mascaras: ultimo.PM25 &gt; 55 || ultimo.CO &gt; LIMITES.CO,&#10;            'se_hidratar-Controlar_humidade': (ultimaUmidade &lt; LIMITES.UMIDADE_MIN || ultimaUmidade &gt; LIMITES.UMIDADE_MAX) || (nivel_alerta === 'CRÍTICO' || nivel_alerta === 'ALTO')&#10;        }&#10;    };&#10;}&#10;&#10;/**&#10; * Busca dados do Arduino e atualiza recomendações&#10; */&#10;async function atualizarRecomendacoes() {&#10;    try {&#10;        // Detecta localização automaticamente se ainda não foi definida&#10;        if (!localizacaoAtual) {&#10;            console.log(' Detectando sua localização...');&#10;            localizacaoAtual = await detectarLocalizacaoPorIP();&#10;            console.log(` Localização detectada: ${localizacaoAtual.nome}`);&#10;            console.log(`   Coordenadas: ${localizacaoAtual.lat}, ${localizacaoAtual.lon}`);&#10;            console.log(`   IP: ${localizacaoAtual.ip}`);&#10;        }&#10;&#10;        const dadosArduino = arduino.obterDados();&#10;&#10;        if (!dadosArduino) {&#10;            console.warn('⏳ Aguardando dados do Arduino...');&#10;            return;&#10;        }&#10;&#10;        // Monta estrutura compatível com calcularRecomendacoes&#10;        const dados = {&#10;            PM25: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.pm25 || 0 }],&#10;            NO2: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.no2 || 0 }],&#10;            O3: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.o3 || 0 }],&#10;            CO: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.co || 0 }],&#10;            RH_2m: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.umidade || 50 }]&#10;        };&#10;&#10;        ultimaRecomendacao = calcularRecomendacoes(dados);&#10;        ultimaRecomendacao.localizacao = localizacaoAtual.nome;&#10;        ultimaRecomendacao.coordenadas = {&#10;            lat: localizacaoAtual.lat,&#10;            lon: localizacaoAtual.lon&#10;        };&#10;        console.log(`[${new Date().toLocaleTimeString()}] ✅ Recomendação atualizada`);&#10;&#10;        // Envia as recomendações de volta para o Arduino&#10;        if (ultimaRecomendacao.recomendacoes) {&#10;            arduino.enviarRecomendacoes(ultimaRecomendacao.recomendacoes);&#10;        }&#10;&#10;    } catch (error) {&#10;        console.error('Erro ao atualizar recomendação:', error.message);&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna as recomendações atuais&#10; */&#10;function obterRecomendacoes() {&#10;    return ultimaRecomendacao;&#10;}&#10;&#10;/**&#10; * Inicializa o sistema de monitoramento&#10; */&#10;async function inicializar() {&#10;    console.log(' Iniciando sistema via Arduino...');&#10;&#10;    // Detecta localização automaticamente na inicialização&#10;    try {&#10;        console.log(' Detectando sua localização...');&#10;        localizacaoAtual = await detectarLocalizacaoPorIP();&#10;        console.log(` Localização detectada: ${localizacaoAtual.nome}`);&#10;        console.log(`   Coordenadas: ${localizacaoAtual.lat}, ${localizacaoAtual.lon}`);&#10;        console.log(`   IP: ${localizacaoAtual.ip}`);&#10;    } catch (error) {&#10;        console.error('❌ Erro ao detectar localização:', error.message);&#10;    }&#10;&#10;    arduino.conectar();&#10;&#10;    // Aguarda 3 segundos antes da primeira leitura&#10;    setTimeout(() =&gt; {&#10;        atualizarRecomendacoes();&#10;        setInterval(atualizarRecomendacoes, 10000); // A cada 10 segundos&#10;    }, 3000);&#10;}&#10;&#10;module.exports = {&#10;    inicializar,&#10;    obterRecomendacoes,&#10;    calcularRecomendacoes,&#10;    calcularHoraPico,&#10;    definirLocalizacao,&#10;    obterLocalizacaoAtual,&#10;    obterCoordenadas,&#10;    detectarLocalizacaoPorIP,&#10;    LIMITES&#10;};" />
              <option name="updatedContent" value="const axios = require('axios');&#10;const arduino = require('../arduino/arduino');&#10;&#10;const LIMITES = {&#10;    PM25: 15,  // µg/m³&#10;    NO2: 200,&#10;    O3: 180,&#10;    CO: 10,&#10;    UMIDADE_MIN: 40,&#10;    UMIDADE_MAX: 60&#10;};&#10;&#10;let ultimaRecomendacao = {&#10;    fechar_janelas: false,&#10;    ativar_purificador: false,&#10;    usar_mascaras: false,&#10;    controlar_umidade: false,&#10;    tempo_para_pico: 0&#10;};&#10;&#10;// Configurações da API Meteomatics&#10;const USERNAME = process.env.METEOMATICS_USER || 'lima_caique';&#10;const PASSWORD = process.env.METEOMATICS_PASS || 'py01s7YnAEAc14VEM952';&#10;&#10;// Localização será detectada automaticamente via IP&#10;let localizacaoAtual = null;&#10;&#10;/**&#10; * Detecta automaticamente a localização do usuário usando API de geolocalização por IP&#10; * @returns {Promise&lt;Object&gt;} - {nome, lat, lon, cidade, pais, ip}&#10; */&#10;async function detectarLocalizacaoPorIP() {&#10;    try {&#10;        // Usando ipapi.co - API gratuita e confiável&#10;        const response = await axios.get('https://ipapi.co/json/', {&#10;            timeout: 5000&#10;        });&#10;&#10;        if (response.data) {&#10;            const dados = response.data;&#10;            return {&#10;                nome: `${dados.city}, ${dados.region}, ${dados.country_name}`,&#10;                lat: dados.latitude.toString(),&#10;                lon: dados.longitude.toString(),&#10;                cidade: dados.city,&#10;                regiao: dados.region,&#10;                pais: dados.country_name,&#10;                codigo_pais: dados.country_code,&#10;                ip: dados.ip&#10;            };&#10;        } else {&#10;            throw new Error('Não foi possível obter dados de localização');&#10;        }&#10;    } catch (error) {&#10;        console.error('Erro ao detectar localização por IP:', error.message);&#10;        // Fallback para São Paulo caso falhe&#10;        console.warn('⚠️ Usando localização padrão (São Paulo)');&#10;        return {&#10;            nome: 'São Paulo, SP, Brasil',&#10;            lat: '-23.5505',&#10;            lon: '-46.6333',&#10;            cidade: 'São Paulo',&#10;            regiao: 'SP',&#10;            pais: 'Brasil',&#10;            codigo_pais: 'BR',&#10;            ip: 'desconhecido'&#10;        };&#10;    }&#10;}&#10;&#10;/**&#10; * Converte nome de localização em coordenadas usando API de geocodificação&#10; * @param {string} local - Nome da cidade/endereço&#10; * @returns {Promise&lt;Object&gt;} - {nome, lat, lon}&#10; */&#10;async function obterCoordenadas(local) {&#10;    // Usando OpenStreetMap Nominatim (gratuito e sem necessidade de API key)&#10;    const url = `https://nominatim.openstreetmap.org/search?format=json&amp;q=${encodeURIComponent(local)}&amp;limit=1`;&#10;&#10;    const response = await axios.get(url, {&#10;        headers: {&#10;            'User-Agent': 'AtmosProject/1.0'&#10;        },&#10;        timeout: 5000&#10;    });&#10;&#10;    if (response.data &amp;&amp; response.data.length &gt; 0) {&#10;        const resultado = response.data[0];&#10;        return {&#10;            nome: resultado.display_name,&#10;            lat: resultado.lat,&#10;            lon: resultado.lon&#10;        };&#10;    } else {&#10;        throw new Error(`Localização &quot;${local}&quot; não encontrada`);&#10;    }&#10;}&#10;&#10;/**&#10; * Define a localização atual do sistema&#10; * @param {string} local - Nome da cidade/endereço&#10; */&#10;async function definirLocalizacao(local) {&#10;    try {&#10;        const novaLocalizacao = await obterCoordenadas(local);&#10;        localizacaoAtual = novaLocalizacao;&#10;        console.log(`Localização atualizada: ${novaLocalizacao.nome}`);&#10;        console.log(`Coordenadas: ${novaLocalizacao.lat}, ${novaLocalizacao.lon}`);&#10;&#10;        // Atualiza recomendações para a nova localização&#10;        await atualizarRecomendacoes();&#10;&#10;        return novaLocalizacao;&#10;    } catch (error) {&#10;        throw new Error(`Não foi possível definir localização: ${error.message}`);&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna a localização atual&#10; */&#10;function obterLocalizacaoAtual() {&#10;    return localizacaoAtual;&#10;}&#10;&#10;/**&#10; * Calcula a regressão linear para prever tendência de crescimento do poluente&#10; * @param {Array} dadosPoluente - Array com objetos {timestamp, valor}&#10; * @returns {Object|null} - {slope, intercept} ou null se dados insuficientes&#10; */&#10;function calcularHoraPico(dadosPoluente) {&#10;    const n = dadosPoluente.length;&#10;    if (n &lt; 2) return null;&#10;&#10;    const y = dadosPoluente.map(d =&gt; d.valor);&#10;&#10;    // Otimização: calcular médias uma única vez&#10;    const yMedia = y.reduce((a, b) =&gt; a + b, 0) / n;&#10;    const xMedia = (n - 1) / 2; // Média de índices 0..n-1&#10;&#10;    let numer = 0, denom = 0;&#10;    for (let i = 0; i &lt; n; i++) {&#10;        const xDiff = i - xMedia;&#10;        numer += xDiff * (y[i] - yMedia);&#10;        denom += xDiff * xDiff;&#10;    }&#10;&#10;    if (denom === 0) return null;&#10;&#10;    const slope = numer / denom;&#10;    const intercept = yMedia - slope * xMedia;&#10;&#10;    return { slope, intercept };&#10;}&#10;&#10;/**&#10; * Calcula recomendações baseadas nos dados de poluentes e umidade&#10; * @param {Object} dados - Objeto com arrays de dados por poluente&#10; * @returns {Object} - Recomendações calculadas com horário de pico&#10; */&#10;function calcularRecomendacoes(dados) {&#10;    const poluentes = ['PM25', 'NO2', 'O3', 'CO'];&#10;    let tempoHorasMin = null;&#10;    let poluenteCritico = null;&#10;    const previsoesPoluentes = {};&#10;&#10;    // Calcula tempo para atingir limite crítico e horário de pico para cada poluente&#10;    for (let poluente of poluentes) {&#10;        if (!dados[poluente] || dados[poluente].length === 0) continue;&#10;&#10;        const valorAtual = dados[poluente][0].valor;&#10;        const result = calcularHoraPico(dados[poluente]);&#10;&#10;        previsoesPoluentes[poluente] = {&#10;            valor_atual: valorAtual,&#10;            limite: LIMITES[poluente],&#10;            tendencia: null,&#10;            horas_para_limite: null,&#10;            horario_pico: null,&#10;            valores_previstos: dados[poluente].slice(0, 6).map(d =&gt; ({&#10;                horario: new Date(d.timestamp).toLocaleTimeString('pt-BR', { hour: '2-digit', minute: '2-digit' }),&#10;                valor: Math.round(d.valor * 10) / 10&#10;            }))&#10;        };&#10;&#10;        if (!result) continue;&#10;&#10;        const { slope } = result;&#10;        const limite = LIMITES[poluente];&#10;&#10;        // Define tendência&#10;        if (slope &gt; 0.5) previsoesPoluentes[poluente].tendencia = 'crescente';&#10;        else if (slope &lt; -0.5) previsoesPoluentes[poluente].tendencia = 'decrescente';&#10;        else previsoesPoluentes[poluente].tendencia = 'estável';&#10;&#10;        // Se está crescendo, calcula quando vai atingir o limite&#10;        if (slope &gt; 0) {&#10;            const horasParaLimite = (limite - valorAtual) / slope;&#10;&#10;            if (horasParaLimite &gt;= 0) {&#10;                const horarioPico = new Date(Date.now() + horasParaLimite * 60 * 60 * 1000);&#10;                previsoesPoluentes[poluente].horas_para_limite = Math.round(horasParaLimite * 10) / 10;&#10;                previsoesPoluentes[poluente].horario_pico = horarioPico.toLocaleString('pt-BR', {&#10;                    day: '2-digit',&#10;                    month: '2-digit',&#10;                    hour: '2-digit',&#10;                    minute: '2-digit'&#10;                });&#10;&#10;                if (tempoHorasMin === null || horasParaLimite &lt; tempoHorasMin) {&#10;                    tempoHorasMin = horasParaLimite;&#10;                    poluenteCritico = poluente;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Categoriza o tempo para pico e nível de alerta&#10;    let tempo_categoria = 0;&#10;    let nivel_alerta = 'BOM';&#10;    let mensagem_alerta = 'Qualidade do ar em níveis aceitáveis';&#10;&#10;    if (tempoHorasMin !== null) {&#10;        if (tempoHorasMin &lt;= 3) {&#10;            tempo_categoria = 3;&#10;            nivel_alerta = 'CRÍTICO';&#10;            mensagem_alerta = `ATENÇÃO: ${poluenteCritico} atingirá nível crítico em menos de 3 horas!`;&#10;        } else if (tempoHorasMin &lt;= 6) {&#10;            tempo_categoria = 2;&#10;            nivel_alerta = 'ALTO';&#10;            mensagem_alerta = `ALERTA: ${poluenteCritico} atingirá nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else if (tempoHorasMin &lt;= 12) {&#10;            tempo_categoria = 1;&#10;            nivel_alerta = 'MODERADO';&#10;            mensagem_alerta = `Atenção: ${poluenteCritico} pode atingir nível crítico em ${Math.round(tempoHorasMin)} horas`;&#10;        } else {&#10;            tempo_categoria = 0;&#10;            nivel_alerta = 'BAIXO';&#10;            mensagem_alerta = `${poluenteCritico} em tendência de crescimento mas ainda seguro`;&#10;        }&#10;    }&#10;&#10;    // Pega valores atuais (primeiro item de cada array)&#10;    const ultimo = {};&#10;    for (let poluente of poluentes) {&#10;        ultimo[poluente] = dados[poluente]?.[0]?.valor || 0;&#10;    }&#10;    const ultimaUmidade = dados['RH_2m']?.[0]?.valor || 50;&#10;&#10;    // Calcula índice de qualidade do ar geral (0-100, quanto menor melhor)&#10;    const indiceQualidade = Math.min(100, Math.round(&#10;        (ultimo.PM25 / LIMITES.PM25 * 30) +&#10;        (ultimo.NO2 / LIMITES.NO2 * 25) +&#10;        (ultimo.O3 / LIMITES.O3 * 25) +&#10;        (ultimo.CO / LIMITES.CO * 20)&#10;    ));&#10;&#10;    return {&#10;        timestamp: new Date().toISOString(),&#10;        nivel_alerta,&#10;        tempo_categoria,&#10;        mensagem: mensagem_alerta,&#10;        poluente_critico: poluenteCritico,&#10;        tempo_ate_pico: {&#10;            horas: tempoHorasMin ? Math.floor(tempoHorasMin) : null,&#10;            minutos: tempoHorasMin ? Math.round((tempoHorasMin % 1) * 60) : null,&#10;            horario_estimado: tempoHorasMin ? new Date(Date.now() + tempoHorasMin * 60 * 60 * 1000).toLocaleString('pt-BR') : null&#10;        },&#10;        indice_qualidade_ar: {&#10;            valor: indiceQualidade,&#10;            categoria: indiceQualidade &lt; 25 ? 'BOM' : indiceQualidade &lt; 50 ? 'REGULAR' : indiceQualidade &lt; 75 ? 'RUIM' : 'PÉSSIMO'&#10;        },&#10;        valores_atuais: ultimo,&#10;        umidade_atual: ultimaUmidade,&#10;        previsoes_por_poluente: previsoesPoluentes,&#10;        recomendacoes: {&#10;            fechar_janelas: ultimo.PM25 &gt; LIMITES.PM25 || ultimo.NO2 &gt; LIMITES.NO2,&#10;            ativar_purificador: ultimo.PM25 &gt; 35 || ultimo.O3 &gt; 70,&#10;            usar_mascaras: ultimo.PM25 &gt; 55 || ultimo.CO &gt; LIMITES.CO,&#10;            'se_hidratar-Controlar_humidade': (ultimaUmidade &lt; LIMITES.UMIDADE_MIN || ultimaUmidade &gt; LIMITES.UMIDADE_MAX) || (nivel_alerta === 'CRÍTICO' || nivel_alerta === 'ALTO')&#10;        }&#10;    };&#10;}&#10;&#10;/**&#10; * Busca dados do Arduino e atualiza recomendações&#10; */&#10;async function atualizarRecomendacoes() {&#10;    try {&#10;        // Detecta localização automaticamente se ainda não foi definida&#10;        if (!localizacaoAtual) {&#10;            console.log(' Detectando sua localização...');&#10;            localizacaoAtual = await detectarLocalizacaoPorIP();&#10;            console.log(` Localização detectada: ${localizacaoAtual.nome}`);&#10;            console.log(`   Coordenadas: ${localizacaoAtual.lat}, ${localizacaoAtual.lon}`);&#10;            console.log(`   IP: ${localizacaoAtual.ip}`);&#10;        }&#10;&#10;        const dadosArduino = arduino.obterDados();&#10;&#10;        if (!dadosArduino) {&#10;            console.warn('⏳ Aguardando dados do Arduino...');&#10;            return;&#10;        }&#10;&#10;        // Monta estrutura compatível com calcularRecomendacoes&#10;        const dados = {&#10;            PM25: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.pm25 || 0 }],&#10;            NO2: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.no2 || 0 }],&#10;            O3: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.o3 || 0 }],&#10;            CO: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.co || 0 }],&#10;            RH_2m: [{ timestamp: dadosArduino.timestamp, valor: dadosArduino.umidade || 50 }]&#10;        };&#10;&#10;        ultimaRecomendacao = calcularRecomendacoes(dados);&#10;        ultimaRecomendacao.localizacao = localizacaoAtual.nome;&#10;        ultimaRecomendacao.coordenadas = {&#10;            lat: localizacaoAtual.lat,&#10;            lon: localizacaoAtual.lon&#10;        };&#10;        console.log(`[${new Date().toLocaleTimeString()}] ✅ Recomendação atualizada`);&#10;&#10;        // Envia as recomendações de volta para o Arduino&#10;        if (ultimaRecomendacao.recomendacoes) {&#10;            arduino.enviarRecomendacoes(ultimaRecomendacao.recomendacoes);&#10;        }&#10;&#10;    } catch (error) {&#10;        console.error('Erro ao atualizar recomendação:', error.message);&#10;    }&#10;}&#10;&#10;/**&#10; * Retorna as recomendações atuais&#10; */&#10;function obterRecomendacoes() {&#10;    return ultimaRecomendacao;&#10;}&#10;&#10;/**&#10; * Inicializa o sistema de monitoramento&#10; */&#10;async function inicializar() {&#10;    console.log(' Iniciando sistema via Arduino...');&#10;&#10;    // Detecta localização automaticamente na inicialização&#10;    try {&#10;        console.log(' Detectando sua localização...');&#10;        localizacaoAtual = await detectarLocalizacaoPorIP();&#10;        console.log(` Localização detectada: ${localizacaoAtual.nome}`);&#10;        console.log(`   Coordenadas: ${localizacaoAtual.lat}, ${localizacaoAtual.lon}`);&#10;        console.log(`   IP: ${localizacaoAtual.ip}`);&#10;    } catch (error) {&#10;        console.error('❌ Erro ao detectar localização:', error.message);&#10;    }&#10;&#10;    arduino.conectar();&#10;&#10;    // Aguarda 3 segundos antes da primeira leitura&#10;    setTimeout(() =&gt; {&#10;        atualizarRecomendacoes();&#10;        setInterval(atualizarRecomendacoes, 10000); // A cada 10 segundos&#10;    }, 3000);&#10;}&#10;&#10;/**&#10; * Obtém dados de poeira atmosférica (Airdust) da NASA GIBS&#10; * @param {number} lat - Latitude&#10; * @param {number} lon - Longitude&#10; * @returns {Promise&lt;Object&gt;} - Dados de airdust&#10; */&#10;async function obterAirdustNASA(lat, lon) {&#10;    try {&#10;        const hoje = new Date().toISOString().split('T')[0];&#10;        &#10;        // NASA GIBS WMS endpoint para dados de poeira MODIS Terra&#10;        const bbox = `${lon - 0.5},${lat - 0.5},${lon + 0.5},${lat + 0.5}`;&#10;        const url = `https://gibs.earthdata.nasa.gov/wms/epsg4326/best/wms.cgi?SERVICE=WMS&amp;REQUEST=GetFeatureInfo&amp;VERSION=1.3.0&amp;LAYERS=MODIS_Terra_Aerosol&amp;QUERY_LAYERS=MODIS_Terra_Aerosol&amp;INFO_FORMAT=application/json&amp;I=50&amp;J=50&amp;WIDTH=100&amp;HEIGHT=100&amp;CRS=EPSG:4326&amp;BBOX=${bbox}&amp;TIME=${hoje}`;&#10;        &#10;        const response = await axios.get(url, {&#10;            timeout: 10000,&#10;            headers: {&#10;                'User-Agent': 'AtmosProject/1.0'&#10;            }&#10;        });&#10;&#10;        return {&#10;            disponivel: true,&#10;            intensidade: response.data?.features?.[0]?.properties?.value || 0,&#10;            data: hoje,&#10;            fonte: 'NASA GIBS - MODIS Terra Aerosol'&#10;        };&#10;    } catch (error) {&#10;        console.warn('⚠️ Dados de airdust NASA indisponíveis:', error.message);&#10;        return {&#10;            disponivel: false,&#10;            intensidade: null,&#10;            erro: error.message&#10;        };&#10;    }&#10;}&#10;&#10;/**&#10; * Obtém dados de incêndios florestais (Wildfire) da NASA FIRMS&#10; * @param {number} lat - Latitude&#10; * @param {number} lon - Longitude&#10; * @returns {Promise&lt;Object&gt;} - Dados de wildfire&#10; */&#10;async function obterWildfireNASA(lat, lon) {&#10;    try {&#10;        // NASA FIRMS API para detecção de incêndios em tempo real&#10;        // Usa dados MODIS e VIIRS dos últimos 7 dias em um raio de 100km&#10;        const url = `https://firms.modaps.eosdis.nasa.gov/api/area/csv/c6e4f8c8e8a0f6b8e8d0f0f8e8f0f8f8/VIIRS_NOAA20_NRT/${lat},${lon}/1`;&#10;        &#10;        const response = await axios.get(url, {&#10;            timeout: 10000,&#10;            headers: {&#10;                'User-Agent': 'AtmosProject/1.0'&#10;            }&#10;        });&#10;&#10;        // Parse CSV response&#10;        const linhas = response.data.split('\n');&#10;        const incendios = [];&#10;        &#10;        if (linhas.length &gt; 1) {&#10;            for (let i = 1; i &lt; linhas.length; i++) {&#10;                const dados = linhas[i].split(',');&#10;                if (dados.length &gt; 5) {&#10;                    incendios.push({&#10;                        latitude: parseFloat(dados[0]),&#10;                        longitude: parseFloat(dados[1]),&#10;                        brilho: parseFloat(dados[2]),&#10;                        confianca: parseFloat(dados[8]),&#10;                        data: dados[5]&#10;                    });&#10;                }&#10;            }&#10;        }&#10;&#10;        const incendiosProximos = incendios.length;&#10;        const nivelRisco = incendiosProximos === 0 ? 'BAIXO' : &#10;                          incendiosProximos &lt;= 2 ? 'MODERADO' : &#10;                          incendiosProximos &lt;= 5 ? 'ALTO' : 'CRÍTICO';&#10;&#10;        return {&#10;            disponivel: true,&#10;            incendios_detectados: incendiosProximos,&#10;            nivel_risco: nivelRisco,&#10;            detalhes: incendios.slice(0, 5), // Primeiros 5 mais próximos&#10;            fonte: 'NASA FIRMS - VIIRS NOAA-20'&#10;        };&#10;    } catch (error) {&#10;        console.warn('⚠️ Dados de wildfire NASA indisponíveis:', error.message);&#10;        return {&#10;            disponivel: false,&#10;            incendios_detectados: null,&#10;            nivel_risco: 'DESCONHECIDO',&#10;            erro: error.message&#10;        };&#10;    }&#10;}&#10;&#10;/**&#10; * Obtém dados combinados da NASA (airdust + wildfire)&#10; * @param {number} lat - Latitude&#10; * @param {number} lon - Longitude&#10; * @returns {Promise&lt;Object&gt;} - Dados combinados&#10; */&#10;async function obterDadosNASA(lat, lon) {&#10;    try {&#10;        const [airdust, wildfire] = await Promise.all([&#10;            obterAirdustNASA(lat, lon),&#10;            obterWildfireNASA(lat, lon)&#10;        ]);&#10;&#10;        return {&#10;            airdust,&#10;            wildfire,&#10;            timestamp: new Date().toISOString()&#10;        };&#10;    } catch (error) {&#10;        console.error('Erro ao obter dados NASA:', error.message);&#10;        return {&#10;            airdust: { disponivel: false },&#10;            wildfire: { disponivel: false },&#10;            erro: error.message&#10;        };&#10;    }&#10;}&#10;&#10;module.exports = {&#10;    inicializar,&#10;    obterRecomendacoes,&#10;    calcularRecomendacoes,&#10;    calcularHoraPico,&#10;    definirLocalizacao,&#10;    obterLocalizacaoAtual,&#10;    obterCoordenadas,&#10;    detectarLocalizacaoPorIP,&#10;    LIMITES,&#10;    obterAirdustNASA,&#10;    obterWildfireNASA,&#10;    obterDadosNASA&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>